<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Buddy AI</title>
  <script src="https://js.puter.com/v2/"></script>
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="icon" href="https://static.vecteezy.com/system/resources/thumbnails/068/082/380/small/artificial-intelligence-design-png.png" type="image/png">
  <style>
    :root {
      --bg-primary: #0f1117;
      --bg-secondary: #161b22;
      --bg-tertiary: #1d232c;
      --accent-primary: #6aa6ff;
      --accent-secondary: #9b6bff;
      --text-primary: #f0f6fc;
      --text-secondary: #8b949e;
      --border: #30363d;
      --success: #3ad29f;
      --warning: #ffcc66;
      --error: #ff6b6b;
      --control-height: 44px;
      --sidebar-width: 280px;
      --radius: 12px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      display: flex;
      height: 100vh;
      overflow: hidden;
      background-image: 
        radial-gradient(ellipse at 10% -10%, rgba(106, 166, 255, 0.1), transparent 50%),
        radial-gradient(ellipse at 90% -20%, rgba(155, 107, 255, 0.08), transparent 50%);
    }

    /* Sidebar */
    .sidebar {
      width: var(--sidebar-width);
      background: var(--bg-secondary);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      height: 100%;
      z-index: 100;
      transition: transform 0.3s ease;
    }

    .sidebar-header {
      padding: 16px 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid var(--border);
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 12px;
      font-weight: 700;
      font-size: 20px;
    }

    .logo-icon {
      width: 32px;
      height: 32px;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .close-sidebar {
      display: none;
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 20px;
      cursor: pointer;
    }

    .sidebar-content {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
    }

    .sidebar-section {
      margin-bottom: 24px;
    }

    .section-title {
      font-size: 14px;
      font-weight: 600;
      text-transform: uppercase;
      color: var(--text-secondary);
      margin-bottom: 12px;
      letter-spacing: 0.5px;
    }

    .new-chat-btn {
      width: 100%;
      padding: 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      color: var(--text-primary);
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.2s;
    }

    .new-chat-btn:hover {
      background: rgba(106, 166, 255, 0.1);
      border-color: var(--accent-primary);
    }

    .conversation-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .conversation-item {
      padding: 12px;
      border-radius: var(--radius);
      cursor: pointer;
      transition: background 0.2s;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .conversation-item.active {
      background: rgba(106, 166, 255, 0.15);
    }

    .conversation-item:hover:not(.active) {
      background: var(--bg-tertiary);
    }

    .conversation-icon {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .conversation-name {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .conversation-actions {
      display: flex;
      gap: 6px;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .conversation-item:hover .conversation-actions {
      opacity: 1;
    }

    .action-btn {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 14px;
      width: 24px;
      height: 24px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .action-btn:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .model-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .model-item {
      padding: 12px;
      border-radius: var(--radius);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .model-item.active {
      background: rgba(106, 166, 255, 0.15);
    }

    .model-item:hover:not(.active) {
      background: var(--bg-tertiary);
    }

    /* Main Content */
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      height: 100%;
      position: relative;
    }

    .topbar {
      padding: 16px 24px;
      display: flex;
      align-items: center;
      gap: 16px;
      border-bottom: 1px solid var(--border);
      background: rgba(22, 27, 34, 0.8);
      backdrop-filter: blur(8px);
      z-index: 10;
    }

    .toggle-sidebar {
      display: none;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .current-conversation {
      font-weight: 600;
      font-size: 18px;
    }

    .chat-container {
      flex: 1;
      overflow-y: auto;
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .message {
      max-width: 800px;
      width: 100%;
      display: flex;
      gap: 16px;
      padding: 16px;
      border-radius: var(--radius);
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .message.user {
      align-self: flex-end;
      border-left: 3px solid var(--accent-primary);
    }

    .message.assistant {
      border-left: 3px solid var(--success);
    }

    .avatar {
      width: 32px;
      height: 32px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .user .avatar {
      background: rgba(106, 166, 255, 0.15);
      color: var(--accent-primary);
    }

    .assistant .avatar {
      background: rgba(58, 210, 159, 0.15);
      color: var(--success);
    }

    .message-content {
      flex: 1;
    }

    .message-header {
      font-weight: 600;
      margin-bottom: 8px;
    }

    .message-body {
      line-height: 1.6;
    }

    .message-body pre {
      background: rgba(16, 20, 26, 0.8);
      border-radius: 8px;
      padding: 16px;
      overflow-x: auto;
      margin: 12px 0;
      font-family: 'Fira Code', monospace;
      font-size: 14px;
      border: 1px solid var(--border);
    }

    .message-body code {
      background: rgba(106, 166, 255, 0.1);
      color: var(--accent-primary);
      padding: 2px 6px;
      border-radius: 4px;
      font-family: 'Fira Code', monospace;
      font-size: 14px;
    }

    .thinking-toggle {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 4px 8px;
      color: var(--text-primary);
      cursor: pointer;
      font-size: 12px;
      display: inline-block;
      margin-top: 8px;
    }

    .thinking-panel-inline {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px;
      margin-top: 6px;
    }

    .thinking-panel-inline .thinking-row {
      font-style: italic;
      color: var(--accent-secondary);
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 8px;
      padding: 6px 0;
    }

    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .dot.pending {
      background: var(--warning);
      animation: pulse 1s ease-in-out infinite;
    }

    @keyframes pulse {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.7; }
      100% { transform: scale(1); opacity: 1; }
    }

    .dot.done {
      background: var(--success);
    }

    .dot.error {
      background: var(--error);
    }

    .composer {
      padding: 16px 24px;
      background: rgba(22, 27, 34, 0.8);
      backdrop-filter: blur(8px);
      border-top: 1px solid var(--border);
    }

    .composer-inner {
      max-width: 800px;
      margin: 0 auto;
      display: flex;
      gap: 12px;
    }

    .composer textarea {
      flex: 1;
      min-height: var(--control-height);
      padding: 12px 16px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      color: var(--text-primary);
      font-family: inherit;
      font-size: 15px;
      resize: none;
      outline: none;
      transition: border-color 0.2s;
    }

    .composer textarea:focus {
      border-color: var(--accent-primary);
    }

    .send-btn, .attach-btn {
      width: var(--control-height);
      height: var(--control-height);
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      border: none;
      border-radius: var(--radius);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .attach-btn {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-primary);
    }

    .send-btn:hover, .attach-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(106, 166, 255, 0.25);
    }

    .send-btn:disabled, .attach-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .send-btn.stop {
      background: linear-gradient(135deg, var(--error), #cc5555);
    }

    .chips {
      max-width: 800px;
      margin: 6px auto 0;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .chip {
      border: 1px dashed var(--border);
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .toolbar {
      display: flex;
      gap: 6px;
      margin-top: 8px;
    }

    .btn {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-primary);
      padding: 6px 10px;
      border-radius: 8px;
      cursor: pointer;
    }

    .btn-icon {
      width: 32px;
      height: 32px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
    }

    .preview-container {
      position: relative;
    }

    .preview-controls {
      display: flex;
      gap: 6px;
      margin: 6px 0 10px;
    }

    .preview-device {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 12px;
    }

    .preview-container.fullscreen {
      position: fixed;
      inset: 0;
      background: var(--bg-primary);
      z-index: 1000;
      padding: 12px;
      overflow: auto;
    }

    .preview-container.fullscreen .preview-frame {
      height: calc(100% - 48px);
    }

    .close-preview {
      position: absolute;
      top: 10px;
      right: 10px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-primary);
      border-radius: 50%;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 100;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .sidebar {
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        transform: translateX(-100%);
      }

      .sidebar.active {
        transform: translateX(0);
      }

      .close-sidebar {
        display: block;
      }

      .toggle-sidebar {
        display: flex;
      }

      .composer-inner {
        gap: 8px;
      }

      .chat-container {
        padding: 16px;
      }
    }
  </style>
</head>
<body>
  <!-- Sidebar -->
  <aside class="sidebar" id="sidebar">
    <div class="sidebar-header">
      <div class="logo">
        <div class="logo-icon">
          <i class="fas fa-robot"></i>
        </div>
        <span>Buddy AI</span>
      </div>
      <button class="close-sidebar" id="closeSidebar">
        <i class="fas fa-times"></i>
      </button>
    </div>
    
    <div class="sidebar-content">
      <div class="sidebar-section">
        <button class="new-chat-btn" id="btnNewChat">
          <i class="fas fa-plus"></i>
          New Chat
        </button>
      </div>
      
      <div class="sidebar-section">
        <div class="section-title">Conversations</div>
        <div class="conversation-list" id="convList"></div>
      </div>
      
      <div class="sidebar-section">
        <div class="section-title">Models</div>
        <div class="model-list" id="modelList"></div>
      </div>
    </div>
  </aside>
  
  <!-- Main Content -->
  <main class="main-content">
    <div class="topbar">
      <button class="toggle-sidebar" id="toggleSidebar">
        <i class="fas fa-bars"></i>
      </button>
      <div class="current-conversation" id="currentConversation">Buddy AI Chat</div>
    </div>
    
    <div class="chat-container" id="chat"></div>
    
    <div class="composer">
      <div class="composer-inner">
        <label class="attach-btn" id="attachBtn" title="Attach (image or text)">
          <input id="attachInput" type="file" accept="image/*,.txt,.md,.json,application/json,text/plain" style="display: none;">
          <i class="fas fa-paperclip"></i>
        </label>
        <textarea id="query" placeholder="Ask Buddy anything..."></textarea>
        <button class="send-btn" id="sendBtn">
          <i class="fas fa-paper-plane"></i>
        </button>
      </div>
      <div id="attachments" class="chips"></div>
    </div>
  </main>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script>
    // UI Elements
    const chatEl = document.getElementById('chat');
    const queryEl = document.getElementById('query');
    const sendBtn = document.getElementById('sendBtn');
    const attachInput = document.getElementById('attachInput');
    const attachmentsEl = document.getElementById('attachments');
    const sidebar = document.getElementById('sidebar');
    const toggleSidebarBtn = document.getElementById('toggleSidebar');
    const closeSidebarBtn = document.getElementById('closeSidebar');
    const btnNewChat = document.getElementById('btnNewChat');
    const convList = document.getElementById('convList');
    const modelList = document.getElementById('modelList');
    const currentConversation = document.getElementById('currentConversation');
    let pendingImage = null;
    let pendingTextFile = null;

    let conversations = [];
    let activeConversationId = null;
    let history = [];
    let selectedModels = null;
    let hasUserModelSelection = false;

    function escapeHtml(str) {
      return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
    }

    function buildMessages(historyArr, userQuery) {
      const msgs = [
        { role: 'system', content: 'You are an expert assistant. Provide accurate, concise, well-structured answers. Do not truncate your output. Return complete results.' }
      ];
      if (Array.isArray(historyArr)) {
        for (const m of historyArr) {
          if (!m || !m.role || !m.content) continue;
          if (m.role === 'user' || m.role === 'assistant' || m.role === 'system') {
            msgs.push({ role: m.role, content: String(m.content) });
          }
        }
      }
      if (userQuery && userQuery.trim()) {
        msgs.push({ role: 'user', content: userQuery });
      }
      return msgs;
    }

    function isErrorText(text) {
      return /^Error:/i.test(String(text || '').trim());
    }

    function isBlank(text) {
      return !String(text || '').trim();
    }

    function extractText(resp) {
      if (!resp) return '';
      if (typeof resp === 'string') return resp;
      if (resp.message?.content) return resp.message.content;
      if (Array.isArray(resp.choices)) {
        const ch = resp.choices[0];
        if (ch?.message?.content) return ch.message.content;
        if (ch?.text) return ch.text;
      }
      if (resp.output_text) return resp.output_text;
      if (resp.text) return resp.text;
      if (typeof resp.content === 'string') return resp.content;
      try { return JSON.stringify(resp); } catch { return String(resp); }
    }

    async function askModel(messages, modelId) {
      try {
        const payload = modelId ? { model: modelId, messages } : { messages };
        const resp = await puter.ai.chat(payload);
        return extractText(resp);
      } catch (e1) {
        try {
          const resp = await puter.ai.chat(messages, modelId ? { model: modelId } : undefined);
          return extractText(resp);
        } catch (e2) {
          console.error(`Error with model ${modelId}:`, e2);
          return `Error: ${e2.message || "Failed to get response"}`;
        }
      }
    }

    async function summarizeCombined(historyArr, query, answersByProvider, summarizer) {
      try {
        const ordered = Object.keys(answersByProvider);
        const bullets = ordered.map(p => `- ${p}: ${(answersByProvider[p] || '').slice(0, 8000)}`).join('\n');
        const prompt = `You are an expert editor that merges multiple AI answers into one concise, accurate, and well-structured response.\n\nUser query:\n${query}\n\nModel answers:\n${bullets}`;
        const msgs = [
          { role: 'system', content: 'You are a careful, reliable editor and synthesizer. Do not truncate. Include all critical details. Keep code complete.' },
          ...historyArr.filter(m => m.role === 'user' || m.role === 'assistant').slice(-6),
          { role: 'user', content: prompt },
        ];
        const response = await askModel(msgs, summarizer);
        const respText = typeof response === 'string' ? response : extractText(response);
        if (respText && !/^Error:/i.test(respText.trim())) return respText;
        const fallbacks = Object.values(answersByProvider)
          .map(v => String(v || ''))
          .filter(v => v && !/^Error:/i.test(v.trim()));
        return fallbacks[0] || 'No combined answer could be generated';
      } catch (e) {
        console.error("Summarizer error:", e);
        return `Combined error: ${e.message || "Unknown error occurred during summarization"}`;
      }
    }

    const CANDIDATE_MODELS = [
      'gpt-4o', 'gpt-4o-mini', 'gpt-4.1', 'gpt-4.1-mini', 'gpt-4.1-nano',
      'o3-mini', 'o1-mini',
      'deepseek-chat', 'deepseek-reasoner',
      'x-ai/grok-4',
      'meta-llama/llama-3.3-70b-instruct',
      'claude-3-5-sonnet'
    ];

    let supportedModels = new Set();

    function loadSupportedModels() {
      try {
        const raw = localStorage.getItem('buddy_supported_models');
        if (!raw) return;
        const obj = JSON.parse(raw);
        if (!obj || !Array.isArray(obj.models)) return;
        supportedModels = new Set(obj.models);
      } catch {}
    }

    function saveSupportedModels() {
      try {
        localStorage.setItem('buddy_supported_models', JSON.stringify({ models: Array.from(supportedModels) }));
      } catch {}
    }

    async function probeModel(modelId) {
      try {
        const msgs = [{ role: 'user', content: 'ok?' }];
        const text = await askModel(msgs, modelId);
        return Boolean(text && !/^Error:/i.test(String(text)));
      } catch {
        return false;
      }
    }

    async function ensureSupportedModels() {
      if (supportedModels.size > 0) return;
      const probes = await Promise.all(
        CANDIDATE_MODELS.map(async (m) => ({ m, ok: await probeModel(m) }))
      );
      supportedModels = new Set(probes.filter(x => x.ok).map(x => x.m));
      if (supportedModels.size === 0) {
        supportedModels = new Set([]);
      }
      saveSupportedModels();
    }

    async function runParallel(modelIds, historyArr, query, summarizer) {
      const messages = buildMessages(historyArr, query);
      const results = {};
      const tasks = [];

      const thinkItems = {};

      for (const model of modelIds) {
        const row = document.createElement('div');
        row.className = 'thinking-row';
        const dot = document.createElement('div');
        dot.className = 'dot pending';
        const name = document.createElement('div');
        name.textContent = model;
        row.appendChild(dot);
        row.appendChild(name);
        thinkItems[model] = { dot, status: name };
      }

      const ids = (modelIds && modelIds.length) ? modelIds : [];
      for (const model of ids) {
        tasks.push(
          askModel(messages, model)
            .then((c) => {
              results[model] = c;
              const t = thinkItems[model];
              if (t) {
                t.dot.className = 'dot done';
                t.status.textContent = `${model} (done)`;
              }
            })
            .catch((e) => {
              results[model] = `Error: ${e.message || "Unknown error"}`;
              const t = thinkItems[model];
              if (t) {
                t.dot.className = 'dot error';
                t.status.textContent = `${model} (error)`;
              }
            })
        );
      }

      if (tasks.length) {
        await Promise.all(tasks);
      }

      try {
        const combined = await summarizeCombined(historyArr, query, results, summarizer);
        return { ...results, combined };
      } catch (e) {
        console.error("Final summarization error:", e);
        return {
          ...results,
          combined: `Failed to generate combined answer: ${e.message || "Unknown error"}`
        };
      }
    }

    function createToolbar(buttons) {
      const bar = document.createElement('div');
      bar.className = 'toolbar';
      for (const { title, icon, onClick } of buttons) {
        const b = document.createElement('button');
        b.className = 'btn btn-icon';
        b.title = title;
        b.innerHTML = `<i class="fas fa-${icon}"></i>`;
        b.onclick = onClick;
        bar.appendChild(b);
      }
      return bar;
    }

    function extractFirstCodeBlock(text) {
      const m = text.match(/```(\w+)?\n([\s\S]*?)```/);
      if (!m) return null;
      return { lang: (m[1] || '').toLowerCase(), code: m[2] || '' };
    }

    function previewCode(code, lang) {
      const html = !lang || lang === 'html' ? code : `<!doctype html><html><head><style>body{margin:16px;}</style></head><body><pre>${escapeHtml(code)}</pre></body></html>`;
      const wrap = document.createElement('div');
      wrap.className = 'message assistant preview-container';
      wrap.innerHTML = '<div class="message-header">Preview</div>';

      const controls = document.createElement('div');
      controls.className = 'preview-controls';
      const btnDesktop = document.createElement('button'); btnDesktop.className = 'preview-device'; btnDesktop.textContent = 'Desktop';
      const btnTablet = document.createElement('button'); btnTablet.className = 'preview-device'; btnTablet.textContent = 'Tablet';
      const btnMobile = document.createElement('button'); btnMobile.className = 'preview-device'; btnMobile.textContent = 'Mobile';
      const btnFullscreen = document.createElement('button'); btnFullscreen.className = 'preview-device'; btnFullscreen.textContent = 'Fullscreen';
      const btnOpenWindow = document.createElement('button'); btnOpenWindow.className = 'preview-device'; btnOpenWindow.textContent = 'Open in new tab';
      controls.appendChild(btnDesktop); controls.appendChild(btnTablet); controls.appendChild(btnMobile); controls.appendChild(btnFullscreen); controls.appendChild(btnOpenWindow);
      wrap.appendChild(controls);

      const closeBtn = document.createElement('button');
      closeBtn.className = 'close-preview';
      closeBtn.innerHTML = '<i class="fas fa-times"></i>';
      closeBtn.onclick = () => wrap.remove();
      wrap.appendChild(closeBtn);

      const iframe = document.createElement('iframe');
      iframe.className = 'preview-frame';
      chatEl.appendChild(wrap);
      wrap.appendChild(iframe);
      const doc = iframe.contentWindow.document;
      doc.open();
      doc.write(html);
      doc.close();

      function setWidth(px) { iframe.style.width = px ? px + 'px' : '100%'; iframe.style.maxWidth = '100%'; }
      btnDesktop.onclick = () => setWidth(1100);
      btnTablet.onclick = () => setWidth(820);
      btnMobile.onclick = () => setWidth(420);
      btnFullscreen.onclick = () => wrap.classList.toggle('fullscreen');
      btnOpenWindow.onclick = () => {
        const w = window.open('', '_blank');
        if (!w) return;
        w.document.open();
        w.document.write(html);
        w.document.close();
      };

      wrap.scrollIntoView({ behavior: 'smooth', block: 'end' });
    }

    const runMeta = new Map();
    const runTimers = new Map();

    function secondsBetween(startMs, endMs) {
      if (!startMs) return 0;
      const end = endMs || Date.now();
      return Math.max(0, Math.round((end - startMs) / 1000));
    }

    function updateThinkingToggleText(index, isOpen) {
      const meta = runMeta.get(index);
      const secs = secondsBetween(meta?.startMs, meta?.endMs);
      const caret = isOpen ? '▾' : '▸';
      return `Thinking ${caret} ${secs}s`;
    }

    function renderInlineThinking(index) {
      const panel = document.getElementById(`think-content-${index}`);
      if (!panel) return;
      panel.innerHTML = '';
      const meta = runMeta.get(index);
      if (!meta) return;
      const header = document.createElement('div');
      header.className = 'message-header';
      header.innerHTML = `Models used: <em>${(meta.models || []).join(', ') || 'default'}</em>`;
      panel.appendChild(header);
      for (const m of meta.models || []) {
        const wrap = document.createElement('div');
        wrap.className = 'thinking-row';
        const title = document.createElement('div');
        title.innerHTML = `<strong>${m}</strong>`;
        const body = document.createElement('div');
        const text = String((meta.results && meta.results[m]) || '').slice(0, 1200);
        body.innerHTML = `<em>${escapeHtml(text || 'thinking…')}</em>`;
        wrap.appendChild(title);
        wrap.appendChild(body);
        panel.appendChild(wrap);
      }
      const combine = document.createElement('div');
      combine.className = 'thinking-row';
      combine.innerHTML = `<div><strong>Buddy combine</strong></div><div><em>Merged overlapping points, resolved conflicts, and structured the final answer.</em></div>`;
      panel.appendChild(combine);
    }

    function startThinkingTimer(index) {
      stopThinkingTimer(index);
      const id = setInterval(() => {
        const toggle = document.getElementById(`think-toggle-${index}`);
        if (!toggle) return;
        const panel = document.getElementById(`think-panel-${index}`);
        const isOpen = panel && !panel.classList.contains('hidden');
        toggle.textContent = updateThinkingToggleText(index, isOpen);
      }, 1000);
      runTimers.set(index, id);
    }

    function stopThinkingTimer(index) {
      const id = runTimers.get(index);
      if (id) {
        clearInterval(id);
        runTimers.delete(index);
      }
    }

    function toggleThinking(index) {
      const panel = document.getElementById(`think-panel-${index}`);
      const toggle = document.getElementById(`think-toggle-${index}`);
      if (!panel || !toggle) return;
      const opening = panel.classList.contains('hidden');
      panel.classList.toggle('hidden');
      toggle.textContent = updateThinkingToggleText(index, opening);
      if (opening) {
        renderInlineThinking(index);
      }
    }

    function renderMessage(role, content, index) {
      const div = document.createElement('div');
      const label = role === 'assistant' ? (history[index]?.meta?.label || 'Buddy') : 'You';
      div.className = `message ${role}`;
      
      let formattedContent = content
        .replace(/```(\w+)?\n([\s\S]*?)```/g, (match, lang, code) => `<pre><code class="language-${(lang || '')}">${escapeHtml(code)}</code></pre>`)
        .replace(/`([^`]+)`/g, (m, c) => `<code>${escapeHtml(c)}</code>`)
        .replace(/__([^_]+)__/g, '<u>$1</u>')
        .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
        .replace(/(^|\s)\*([^*]+)\*(?=\s|$)/g, '$1<em>$2</em>')
        .replace(/\n\n+/g, '</p><p>')
        .replace(/\n/g, '<br/>');
      formattedContent = `<p>${formattedContent}</p>`;
      
      div.innerHTML = `
        <div class="avatar">
          <i class="fas fa-${role === 'user' ? 'user' : 'robot'}"></i>
        </div>
        <div class="message-content">
          <div class="message-header">${label}</div>
          <div class="message-body">${formattedContent}</div>
        </div>
      `;

      if (role === 'user' && index === history.length - 1) {
        const thinkToggle = document.createElement('button');
        thinkToggle.id = `think-toggle-${index}`;
        thinkToggle.className = 'thinking-toggle';
        thinkToggle.textContent = 'Thinking ▸ 0s';
        const thinkPanel = document.createElement('div');
        thinkPanel.id = `think-panel-${index}`;
        thinkPanel.className = 'thinking-panel-inline hidden';
        const contentWrap = document.createElement('div');
        contentWrap.id = `think-content-${index}`;
        thinkPanel.appendChild(contentWrap);
        thinkToggle.onclick = () => toggleThinking(index);
        div.querySelector('.message-content').appendChild(thinkToggle);
        div.querySelector('.message-content').appendChild(thinkPanel);
      }

      const buttons = [];
      if (role === 'user') {
        buttons.push({ title: 'Copy', icon: 'copy', onClick: () => navigator.clipboard.writeText(content) });
        buttons.push({ title: 'Edit', icon: 'edit', onClick: () => editPrompt(index) });
        buttons.push({ title: 'Delete', icon: 'trash', onClick: () => deletePrompt(index) });
      } else {
        buttons.push({ title: 'Copy Answer', icon: 'copy', onClick: () => navigator.clipboard.writeText(content) });
        const code = extractFirstCodeBlock(content);
        if (code) buttons.push({ title: 'Preview', icon: 'eye', onClick: () => previewCode(code.code, code.lang) });
      }
      div.querySelector('.message-content').appendChild(createToolbar(buttons));
      chatEl.appendChild(div);
      div.scrollIntoView({ behavior: 'smooth', block: 'end' });
    }

    function setSidebarOpen(open) {
      if (open) {
        sidebar.classList.add('active');
      } else {
        sidebar.classList.remove('active');
      }
    }

    toggleSidebarBtn.addEventListener('click', () => setSidebarOpen(!sidebar.classList.contains('active')));
    closeSidebarBtn.addEventListener('click', () => setSidebarOpen(false));

    queryEl.addEventListener('input', () => {
      queryEl.style.height = 'auto';
      queryEl.style.height = `${queryEl.scrollHeight}px`;
    });

    queryEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        send();
      }
    });

    sendBtn.addEventListener('click', () => {
      if (sendBtn.classList.contains('stop')) {
        abortAll();
      } else {
        send();
      }
    });

    attachInput.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;

      if (file.type.startsWith('image/')) {
        try {
          const dataUrl = await fileToDataURL(file);
          pendingImage = dataUrl;
          const chip = document.createElement('div');
          chip.className = 'chip';
          chip.textContent = `Image: ${file.name}`;
          attachmentsEl.appendChild(chip);
        } catch (e) {
          console.error("Error processing image:", e);
        }
      } else if (file.type.startsWith('text') || /\.(md|json|txt)$/i.test(file.name)) {
        try {
          pendingTextFile = await file.text();
          const chip = document.createElement('div');
          chip.className = 'chip';
          chip.textContent = `File: ${file.name}`;
          attachmentsEl.appendChild(chip);
        } catch (e) {
          console.error("Error reading text file:", e);
        }
      } else {
        alert('Only images or text/md/json files supported');
      }
      e.target.value = '';
    });

    function fileToDataURL(file) {
      return new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = () => resolve(r.result);
        r.onerror = reject;
        r.readAsDataURL(file);
      });
    }

    async function ocrImage(dataUrl) {
      try {
        return await puter.ai.img2txt(dataUrl);
      } catch (e1) {
        try {
          return await puter.ai.img2txt({ image: dataUrl });
        } catch (e2) {
          console.error('Image OCR error:', e2);
          return null;
        }
      }
    }

    let inFlightAbort = null;

    function setComposeBusy(busy) {
      if (busy) {
        sendBtn.classList.add('stop');
        sendBtn.innerHTML = '<i class="fas fa-stop"></i>';
        document.getElementById('attachBtn').classList.add('disabled');
      } else {
        sendBtn.classList.remove('stop');
        sendBtn.innerHTML = '<i class="fas fa-paper-plane"></i>';
        document.getElementById('attachBtn').classList.remove('disabled');
      }
    }

    function abortAll() {
      if (inFlightAbort) inFlightAbort.abort();
    }

    async function send() {
      const q = queryEl.value.trim();
      if (!q) return;

      setComposeBusy(true);
      queryEl.value = '';
      queryEl.dispatchEvent(new Event('input'));

      let enriched = q;
      if (pendingImage) {
        const text = await ocrImage(pendingImage);
        if (text) enriched += `\n\n[Image OCR]:\n${text}`;
      }
      if (pendingTextFile) {
        enriched += `\n\n[Attached text]:\n${pendingTextFile.slice(0, 20000)}`;
      }

      const userIndex = history.length;
      const msg = { role: 'user', content: enriched };
      if (pendingImage) msg.images = [pendingImage];
      if (pendingTextFile) msg.files = [{ name: 'attachment.txt', type: 'text/plain', content: pendingTextFile.slice(0, 20000) }];

      history.push(msg);
      runMeta.set(userIndex, { startMs: Date.now(), models: null, results: null, combined: null });
      renderMessage('user', enriched, userIndex);
      startThinkingTimer(userIndex);
      attachmentsEl.innerHTML = '';
      pendingImage = null;
      pendingTextFile = null;

      try {
        inFlightAbort = new AbortController();
        await ensureSupportedModels();
        const baseList = supportedModels.size ? Array.from(supportedModels) : [];
        let modelsToUse = Array.from(selectedModels || new Set(baseList)).filter(m => !supportedModels.size || supportedModels.has(m));
        if (hasUserModelSelection) {
          const chosen = Array.from(selectedModels || []);
          modelsToUse = chosen.filter(m => !supportedModels.size || supportedModels.has(m));
        }
        const summarizerModel = (supportedModels.has('gpt-4o') ? 'gpt-4o' : (modelsToUse[0] || null));
        const startMs = Date.now();
        const meta = runMeta.get(userIndex) || {};
        meta.models = modelsToUse.slice();
        const result = await runParallel(modelsToUse, history, enriched, summarizerModel);
        let assistantContent = result.combined || '';
        const nonErrorProvider = Object.entries(result)
          .filter(([k, v]) => k !== 'combined' && typeof v === 'string')
          .map(([_, v]) => v)
          .find(v => !isErrorText(v));
        if (isBlank(assistantContent) || isErrorText(assistantContent)) {
          if (nonErrorProvider && !isBlank(nonErrorProvider)) {
            assistantContent = nonErrorProvider;
          } else {
            const fallbackMessages = buildMessages(history, '');
            const fallback = await askModel(fallbackMessages, null);
            const fallbackText = extractText(fallback);
            assistantContent = isBlank(fallbackText) || isErrorText(fallbackText) ? '[No combined answer could be generated]' : fallbackText;
          }
        }
        const aiIndex = history.length;
        const label = (modelsToUse && modelsToUse.length > 1) ? 'Buddy - Combined' : 'Buddy';
        meta.results = Object.fromEntries(Object.entries(result).filter(([k]) => k !== 'combined'));
        meta.combined = assistantContent;
        meta.endMs = Date.now();
        runMeta.set(userIndex, meta);
        history.push({ role: 'assistant', content: assistantContent, meta: { label } });
        renderMessage('assistant', assistantContent, aiIndex);
        stopThinkingTimer(userIndex);
      } catch (e) {
        console.error("Send error:", e);
        const errorMsg = `Error: ${e.message || "Failed to get response"}`;
        const aiIndex = history.length;
        history.push({ role: 'assistant', content: errorMsg });
        renderMessage('assistant', errorMsg, aiIndex);
      } finally {
        inFlightAbort = null;
        setComposeBusy(false);
      }
    }

    let activeEditIndex = null;
    function editPrompt(index) {
      if (activeEditIndex !== null) return;
      const original = history[index];
      if (!original || original.role !== 'user') return;

      activeEditIndex = index;
      const bubbles = [...chatEl.children];
      const bubble = bubbles[index];
      if (!bubble) return;

      const body = bubble.querySelector('.message-body');
      const originalText = original.content;
      body.innerHTML = '';

      const ta = document.createElement('textarea');
      ta.className = 'composer';
      ta.style.width = '100%';
      ta.style.minHeight = '120px';
      ta.style.maxHeight = 'none';
      ta.value = originalText;

      const bar = document.createElement('div');
      bar.className = 'toolbar';

      const saveBtn = document.createElement('button');
      saveBtn.className = 'btn';
      saveBtn.textContent = 'Save';

      const cancelBtn = document.createElement('button');
      cancelBtn.className = 'btn';
      cancelBtn.textContent = 'Cancel';

      bar.appendChild(saveBtn);
      bar.appendChild(cancelBtn);
      body.appendChild(ta);
      body.appendChild(bar);

      saveBtn.onclick = () => saveEdit(index, ta.value);
      cancelBtn.onclick = () => cancelEdit(index, originalText);
    }

    function cancelEdit(index, originalText) {
      activeEditIndex = null;
      const bubbles = [...chatEl.children];
      const bubble = bubbles[index];
      if (!bubble) return;

      const body = bubble.querySelector('.message-body');
      body.innerHTML = originalText
        .replace(/```(\w+)?\n([\s\S]*?)```/g, (match, lang, code) => `<pre><code class="language-${(lang || '')}">${escapeHtml(code)}</code></pre>`)
        .replace(/`([^`]+)`/g, (m, c) => `<code>${escapeHtml(c)}</code>`)
        .replace(/__([^_]+)__/g, '<u>$1</u>')
        .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
        .replace(/(^|\s)\*([^*]+)\*(?=\s|$)/g, '$1<em>$2</em>')
        .replace(/\n\n+/g, '</p><p>')
        .replace(/\n/g, '<br/>');
      body.insertAdjacentHTML('beforeend', `<p>${body.innerHTML}</p>`);
      const buttons = [
        { title: 'Copy', icon: 'copy', onClick: () => navigator.clipboard.writeText(originalText) },
        { title: 'Edit', icon: 'edit', onClick: () => editPrompt(index) },
        { title: 'Delete', icon: 'trash', onClick: () => deletePrompt(index) }
      ];
      body.appendChild(createToolbar(buttons));
    }

    function saveEdit(index, newText) {
      activeEditIndex = null;
      history[index].content = newText;
      while (history.length > index + 1) history.pop();

      chatEl.innerHTML = '';
      for (let i = 0; i <= index; i++) {
        renderMessage(history[i].role, history[i].content, i);
      }

      (async () => {
        setComposeBusy(true);
        try {
          await ensureSupportedModels();
          const baseList = supportedModels.size ? Array.from(supportedModels) : [];
          let modelsToUse = Array.from(selectedModels || new Set(baseList)).filter(m => !supportedModels.size || supportedModels.has(m));
          if (hasUserModelSelection) {
            const chosen = Array.from(selectedModels || []);
            modelsToUse = chosen.filter(m => !supportedModels.size || supportedModels.has(m));
          }
          const summarizerModel = (supportedModels.has('gpt-4o') ? 'gpt-4o' : (modelsToUse[0] || null));
          const startMs = Date.now();
          const result = await runParallel(modelsToUse, history, newText, summarizerModel);
          let assistantContent = result.combined || '';
          const nonErrorProvider = Object.entries(result)
            .filter(([k, v]) => k !== 'combined' && typeof v === 'string')
            .map(([_, v]) => v)
            .find(v => !isErrorText(v));
          if (isBlank(assistantContent) || isErrorText(assistantContent)) {
            if (nonErrorProvider && !isBlank(nonErrorProvider)) {
              assistantContent = nonErrorProvider;
            } else {
              const fallbackMessages = buildMessages(history, '');
              const fallback = await askModel(fallbackMessages, null);
              const fallbackText = extractText(fallback);
              assistantContent = isBlank(fallbackText) || isErrorText(fallbackText) ? '[No combined answer could be generated]' : fallbackText;
            }
          }
          const aiIndex = history.length;
          const label = (modelsToUse && modelsToUse.length > 1) ? 'Buddy - Combined' : 'Buddy';
          const meta = runMeta.get(index) || {};
          meta.endMs = Date.now();
          runMeta.set(index, meta);
          history.push({ role: 'assistant', content: assistantContent, meta: { label } });
          renderMessage('assistant', assistantContent, aiIndex);
          stopThinkingTimer(index);
        } catch (e) {
          console.error("Error after edit:", e);
        } finally {
          setComposeBusy(false);
        }
      })();
    }

    function deletePrompt(index) {
      if (!history[index] || history[index].role !== 'user') return;
      history.splice(index);
      chatEl.innerHTML = '';
      for (let i = 0; i < history.length; i++) {
        renderMessage(history[i].role, history[i].content, i);
      }
    }

    function saveState() {
      const state = {
        conversations,
        activeConversationId,
        selectedModels: Array.from(selectedModels || [])
      };
      localStorage.setItem('buddy_state', JSON.stringify(state));
    }

    function loadState() {
      try {
        const raw = localStorage.getItem('buddy_state');
        if (!raw) throw new Error('no saved state');
        const st = JSON.parse(raw);
        conversations = Array.isArray(st.conversations) ? st.conversations : [];
        activeConversationId = st.activeConversationId || null;
        const base = supportedModels.size ? Array.from(supportedModels) : CANDIDATE_MODELS;
        const restored = Array.isArray(st.selectedModels) && st.selectedModels.length ? st.selectedModels : base;
        selectedModels = new Set(restored.filter(m => !supportedModels.size || supportedModels.has(m)));
      } catch {
        conversations = [];
        activeConversationId = null;
        const base = supportedModels.size ? Array.from(supportedModels) : CANDIDATE_MODELS;
        selectedModels = new Set(base);
      }
    }

    function ensureDefaultConversation() {
      if (!conversations.length) {
        const conv = {
          id: String(Date.now()),
          name: 'New Chat',
          history: []
        };
        conversations.push(conv);
        activeConversationId = conv.id;
      }
    }

    function setActiveConversation(id) {
      activeConversationId = id;
      const conv = conversations.find(c => c.id === id);
      history = conv.history;
      chatEl.innerHTML = '';
      for (let i = 0; i < history.length; i++) {
        renderMessage(history[i].role, history[i].content, i);
      }
      currentConversation.textContent = conv.name;
      saveState();
      renderConversationList();
    }

    function newChat() {
      const conv = {
        id: String(Date.now()),
        name: 'New Chat',
        history: []
      };
      conversations.unshift(conv);
      saveState();
      setActiveConversation(conv.id);
    }

    function renameConversation(id, newName) {
      const c = conversations.find(x => x.id === id);
      if (!c) return;
      c.name = newName || 'Untitled';
      currentConversation.textContent = c.name;
      saveState();
      renderConversationList();
    }

    function deleteConversation(id) {
      const idx = conversations.findIndex(x => x.id === id);
      if (idx === -1) return;

      conversations.splice(idx, 1);
      if (!conversations.length) {
        ensureDefaultConversation();
      }

      if (activeConversationId === id) {
        setActiveConversation(conversations[0].id);
      } else {
        saveState();
        renderConversationList();
      }
    }

    async function exportConversationPdf(id) {
      const c = conversations.find(x => x.id === id);
      if (!c) return;

      const { jsPDF } = window.jspdf;
      const doc = new jsPDF({ unit: 'pt', format: 'a4' });
      const pageWidth = doc.internal.pageSize.getWidth();
      let y = 36;
      const lineHeight = 16;

      doc.setFont('helvetica', '');
      doc.setFontSize(12);
      doc.text(`Conversation: ${c.name}`, 36, y);
      y += 24;

      for (const m of c.history) {
        doc.setFont(undefined, 'bold');
        doc.text(m.role.toUpperCase() + ':', 36, y);
        y += lineHeight;
        doc.setFont(undefined, 'normal');

        const text = (m.content || '').replace(/\r/g, '');
        const lines = doc.splitTextToSize(text, pageWidth - 72);

        for (const ln of lines) {
          if (y > 780) {
            doc.addPage();
            y = 36;
          }
          doc.text(ln, 36, y);
          y += lineHeight;
        }

        if (Array.isArray(m.images)) {
          for (const img of m.images) {
            if (y > 700) {
              doc.addPage();
              y = 36;
            }
            try {
              doc.addImage(img, 'PNG', 36, y, pageWidth - 72, (pageWidth - 72) * 0.56);
              y += 12 + (pageWidth - 72) * 0.56;
            } catch (e) {
              console.error("Error adding image:", e);
            }
          }
        }

        if (Array.isArray(m.files)) {
          for (const f of m.files) {
            const label = f.type && f.type.startsWith('text') ? `File (${f.name}):` : `Attachment: ${f.name}`;
            if (y > 780) {
              doc.addPage();
              y = 36;
            }
            doc.setFont(undefined, 'bold');
            doc.text(label, 36, y);
            y += lineHeight;
            doc.setFont(undefined, 'normal');

            if (f.content && typeof f.content === 'string') {
              const flines = doc.splitTextToSize(f.content.slice(0, 5000), pageWidth - 72);
              for (const ln of flines) {
                if (y > 780) {
                  doc.addPage();
                  y = 36;
                }
                doc.text(ln, 36, y);
                y += lineHeight;
              }
            }
          }
        }
        y += 8;
      }
      doc.save(`${c.name.replace(/[^a-z0-9\-_]+/gi, '_')}.pdf`);
    }

    function renderConversationList() {
      convList.innerHTML = '';
      for (const c of conversations) {
        const row = document.createElement('div');
        row.className = 'conversation-item';
        if (activeConversationId === c.id) {
          row.classList.add('active');
        }

        const icon = document.createElement('div');
        icon.className = 'conversation-icon';
        icon.innerHTML = '<i class="fas fa-comment"></i>';

        const input = document.createElement('input');
        input.className = 'conversation-name';
        input.value = c.name;
        input.title = 'Click to edit name';
        input.onchange = () => renameConversation(c.id, input.value);
        input.onclick = (e) => {
          if (activeConversationId !== c.id) setActiveConversation(c.id);
        };

        const actions = document.createElement('div');
        actions.className = 'conversation-actions';

        const del = document.createElement('button');
        del.className = 'action-btn';
        del.innerHTML = '<i class="fas fa-trash"></i>';
        del.title = 'Delete';
        del.onclick = () => deleteConversation(c.id);

        const exp = document.createElement('button');
        exp.className = 'action-btn';
        exp.innerHTML = '<i class="fas fa-download"></i>';
        exp.title = 'Export PDF';
        exp.onclick = () => exportConversationPdf(c.id);

        actions.appendChild(exp);
        actions.appendChild(del);

        row.appendChild(icon);
        row.appendChild(input);
        row.appendChild(actions);

        convList.appendChild(row);
      }
    }

    function renderModelList() {
      modelList.innerHTML = '';
      const list = supportedModels.size ? Array.from(supportedModels) : CANDIDATE_MODELS;
      for (const mid of list) {
        const row = document.createElement('label');
        row.className = 'model-item';

        const icon = document.createElement('div');
        icon.className = 'conversation-icon';
        icon.innerHTML = '<i class="fas fa-brain"></i>';

        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = (selectedModels || new Set(list)).has(mid);
        cb.onchange = () => {
          if (!selectedModels) selectedModels = new Set(list);
          if (cb.checked) selectedModels.add(mid);
          else selectedModels.delete(mid);
          hasUserModelSelection = true;
          saveState();
        };

        const span = document.createElement('span');
        span.className = 'conversation-name';
        span.textContent = mid;

        row.appendChild(icon);
        row.appendChild(cb);
        row.appendChild(span);
        modelList.appendChild(row);
      }
    }

    btnNewChat.addEventListener('click', newChat);

    // Initialize the app
    (async () => {
      loadSupportedModels();
      await ensureSupportedModels();
      loadState();
      ensureDefaultConversation();
      history = (conversations.find(c => c.id === activeConversationId) || conversations[0]).history;
      activeConversationId = (conversations.find(c => c.id === activeConversationId) || conversations[0]).id;
      renderConversationList();
      renderModelList();
      setActiveConversation(activeConversationId);
    })();
  </script>
</body>
</html>
