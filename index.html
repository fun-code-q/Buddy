<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Buddy AI</title>
  <script src="https://js.puter.com/v2/"></script>
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
  <link rel="icon" href="https://static.vecteezy.com/system/resources/thumbnails/068/082/380/small/artificial-intelligence-design-png.png" type="image/png">
  <style>
    :root {
      --bg: #0b0d10;
      --panel: #12151a;
      --user-bubble: #111824;
      --buddy-bubble: #0f1a13;
      --muted: #9aa4b2;
      --text: #e8eef5;
      --accent: #6aa6ff;
      --accent-2: #9b6bff;
      --border: #1f2430;
      --ok: #3ad29f;
      --warn: #ffcc66;
      --err: #ff6b6b;
      --control-h: 44px;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 10% -10%, rgba(106,166,255,0.15), transparent 50%),
                  radial-gradient(1000px 600px at 110% -20%, rgba(155,107,255,0.12), transparent 50%),
                  var(--bg);
      color: var(--text);
    }
    .container {
      max-width: 1100px;
      margin: 0 auto;
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .header { display: none; }
    .title {
      font-size: 22px;
      font-weight: 700;
      letter-spacing: 0.2px;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px 16px;
      align-items: center;
    }
    .toggle-group, .mode-group {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      display: flex;
      gap: 14px;
      align-items: center;
    }
    .toggle {
      display: flex;
      gap: 8px;
      align-items: center;
      color: var(--muted);
      font-size: 14px;
    }
    .mode-extra {
      display: none;
      gap: 8px;
      align-items: center;
    }
    .input-bar {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 12px;
      display: flex;
      gap: 10px;
      align-items: center;
    }
    textarea {
      width: 100%;
      min-height: 60px;
      max-height: 200px;
      resize: vertical;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text);
      outline: none;
      font-size: 15px;
    }
    button#sendBtn {
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      color: white;
      border: none;
      padding: 12px 16px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
    }
    button#sendBtn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .chat {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    .bubble {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 14px;
      line-height: 1.5;
    }
    .bubble.user { border-left: 3px solid var(--accent); background: var(--user-bubble); }
    .bubble.assistant { border-left: 3px solid var(--ok); background: var(--buddy-bubble); }
    .providers {
      display: grid;
      gap: 10px;
    }
    .provider-card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
    }
    .provider-title {
      font-weight: 700;
      margin-bottom: 6px;
    }
    .muted { color: var(--muted); }
    .small { font-size: 12px; }
    .combined {
      border-left: 3px solid var(--ok);
    }
    code, pre { 
      white-space: pre-wrap;
      font-family: 'Fira Code', 'Consolas', monospace;
    }
    .bubble .body pre {
      background: var(--user-bubble);
      border-radius: 8px;
      padding: 12px;
      overflow-x: auto;
      border: 1px solid var(--border);
      font-family: 'Fira Code', 'Consolas', monospace;
      font-size: 14px;
      line-height: 1.4;
      margin: 8px 0;
      tab-size: 4;
    }
    .bubble .body code {
      font-family: inherit;
      color: var(--accent);
      background: rgba(106, 166, 255, 0.1);
      padding: 2px 4px;
      border-radius: 4px;
    }
    .token.keyword { color: var(--accent-2); }
    .token.comment { color: var(--muted); }
    .token.string { color: var(--ok); }
    .token.function { color: var(--accent); }
    .token.tag { color: var(--err); }
    a { color: var(--accent); }
  </style>
  <style>
    .topbar { position: fixed; top: 0; left: 0; right: 0; z-index: 20; display: grid; grid-template-columns: auto 1fr auto; align-items: center; gap: 12px; background: rgba(18,21,26,0.9); backdrop-filter: blur(8px); border-bottom: 1px solid var(--border); padding: 10px 12px; }
    .burger { width: 36px; height: 36px; border-radius: 8px; border: 1px solid var(--border); background: var(--panel); color: var(--text); display: inline-flex; align-items: center; justify-content: center; cursor: pointer; }
    .brand { font-weight: 700; letter-spacing: 0.3px; }
    .topbar-left { display: inline-flex; align-items: center; gap: 10px; }
    .topbar-center { justify-self: center; text-align: center; }
    .topbar-note { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .sidebar { position: fixed; top: 56px; bottom: 0; left: 0; width: 280px; background: var(--panel); border-right: 1px solid var(--border); transform: translateX(-100%); transition: transform .2s ease; z-index: 25; padding: 12px 12px 140px; overflow: auto; display: flex; flex-direction: column; }
    .sidebar.open { transform: translateX(0); }
    .backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.35); backdrop-filter: blur(2px); opacity: 0; pointer-events: none; transition: opacity .2s ease; z-index: 9; }
    .backdrop.show { opacity: 1; pointer-events: auto; }
    .sb-section { margin-bottom: 16px; }
    .sb-title { font-weight: 700; margin-bottom: 8px; }
    .sb-title-row { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 8px; }
    .conv-item { display: grid; grid-template-columns: 1fr auto auto; gap: 6px; align-items: center; padding: 6px; border: 1px solid var(--border); border-radius: 8px; margin-bottom: 6px; }
    .conv-name { background: transparent; color: var(--text); border: none; outline: none; width: 100%; }
    .icon { background: var(--panel); border: 1px solid var(--border); color: var(--text); width: 28px; height: 28px; border-radius: 6px; display: inline-flex; align-items: center; justify-content: center; cursor: pointer; }
    .model-list { display: grid; gap: 6px; max-height: 260px; overflow: auto; border: 1px solid var(--border); border-radius: 8px; padding: 8px; }
    .model-row { display: flex; align-items: center; gap: 8px; font-size: 13px; }
    .hidden { display: none; }
    .sb-models { position: sticky; bottom: 0; background: var(--panel); padding-top: 8px; border-top: 1px solid var(--border); }
    .composer {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      border-top: 1px solid var(--border);
      background: rgba(18,21,26,0.9);
      backdrop-filter: blur(8px);
      padding: 10px 12px;
    }
    .composer-inner { max-width: 1100px; margin: 0 auto; display: grid; grid-template-columns: auto 1fr auto; gap: 8px; align-items: center; }
    .attach { display: flex; gap: 6px; align-items: center; }
    .icon-btn { background: var(--panel); border: 1px solid var(--border); border-radius: 10px; width: var(--control-h); height: var(--control-h); padding: 0; cursor: pointer; display: inline-flex; align-items: center; justify-content: center; }
    .icon-btn input[type=file] { display: none; }
    .chips { max-width: 1100px; margin: 6px auto 0; display: flex; gap: 8px; flex-wrap: wrap; }
    .chip { border: 1px dashed var(--border); border-radius: 8px; padding: 6px 8px; }
    .toolbar { display: flex; gap: 6px; margin-top: 8px; }
    .btn { background: var(--panel); border: 1px solid var(--border); color: var(--text); padding: 6px 10px; border-radius: 8px; cursor: pointer; }
    .btn-icon { width: 32px; height: 32px; display: inline-flex; align-items: center; justify-content: center; border-radius: 8px; }
    .send { display: inline-flex; align-items: center; justify-content: center; width: var(--control-h); height: var(--control-h); background: linear-gradient(135deg, var(--accent), var(--accent-2)); color: #fff; border: none; border-radius: 12px; cursor: pointer; font-weight: 600; }
    .send:disabled { opacity: .6; cursor: not-allowed; }
    .send.stop { background: linear-gradient(135deg, var(--err), #cc5555); }
    .preview-frame { width: 100%; height: 420px; border: 1px solid var(--border); border-radius: 12px; background: #fff; }
    .spacer { height: 120px; }
    @media (max-width: 640px) {
      .composer-inner { grid-template-columns: auto 1fr auto; }
      .attach { grid-column: auto; }
      .brand { font-size: 16px; }
      .topbar-note { white-space: normal; font-size: 11px; }
      body { background: var(--bg) !important; background-attachment: fixed; }
      .container { padding-left: 8px; padding-right: 8px; }
    }
  </style>
  <style>
    .composer textarea {
      min-height: var(--control-h);
      height: auto;
      max-height: none;
      padding: 10px 12px;
      overflow-y: hidden;
    }
    .topbar-right { justify-self: end; }
    .dropdown { position: fixed; top: 56px; right: 12px; width: 320px; max-height: 50vh; overflow: auto; background: var(--panel); border: 1px solid var(--border); border-radius: 10px; padding: 10px; z-index: 12; }
    .thinking-row { display: grid; grid-template-columns: auto 1fr auto; gap: 8px; align-items: center; padding: 6px 0; }
    .dot { width: 10px; height: 10px; border-radius: 50%; }
    .dot.pending { background: #caa85a; }
    @keyframes pulse {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.7; }
      100% { transform: scale(1); opacity: 1; }
    }
    .dot.pending { animation: pulse 1s ease-in-out infinite; }
    .dot.done { background: #3ad29f; }
    .dot.error { background: #ff6b6b; }
    .hidden { display: none; }
    /* Hide topbar thinking UI; inline thinking is used instead */
    #btnThinking, #thinkingPanel { display: none !important; }
    .preview-container {
      position: relative;
    }
    .preview-controls { display: flex; gap: 6px; margin: 6px 0 10px; }
    .preview-device { background: var(--panel); border: 1px solid var(--border); border-radius: 6px; padding: 4px 8px; cursor: pointer; font-size: 12px; }
    .preview-container.fullscreen { position: fixed; inset: 0; background: var(--panel); z-index: 1000; padding: 12px; overflow: auto; }
    .preview-container.fullscreen .preview-frame { height: calc(100% - 48px); }
    .preview-inner { max-width: 100%; margin: 0 auto; }
    .close-preview {
      position: absolute;
      top: 10px;
      right: 10px;
      background: var(--panel);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 50%;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 100;
    }
    /* Attach disabled */
    #attachBtn.disabled { opacity: 0.5; pointer-events: none; }
    
    /* Inline thinking UI */
    .thinking-toggle { background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 4px 8px; color: var(--text); cursor: pointer; font-size: 12px; display: inline-block; }
    .thinking-panel-inline { background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 8px; margin-top: 6px; }
    .thinking-panel-inline .thinking-row { font-style: italic; color: var(--accent-2); }
    /* Builder UI */
    .builder { margin-top: 16px; background: var(--panel); border: 1px solid var(--border); border-radius: 12px; }
    .builder-controls { display: flex; flex-wrap: wrap; gap: 8px; padding: 10px; border-bottom: 1px solid var(--border); }
    .builder-main { display: grid; grid-template-columns: 280px 1fr; gap: 0; min-height: 420px; }
    .project-tree { border-right: 1px solid var(--border); padding: 10px; overflow: auto; }
    .tree-item { display: flex; align-items: center; gap: 6px; padding: 4px 6px; border-radius: 6px; cursor: pointer; }
    .tree-item.active { background: rgba(106,166,255,0.14); }
    .tree-folder { font-weight: 600; }
    .tree-actions { margin-left: auto; display: inline-flex; gap: 6px; }
    .right-pane { padding: 10px; display: grid; grid-template-rows: auto minmax(280px, 1fr) auto; gap: 8px; }
    .editor-tabs { display: inline-flex; gap: 6px; }
    .tab { background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 6px 10px; cursor: pointer; }
    .tab.active { border-color: var(--accent); color: var(--accent); }
    .editor-pane, .preview-pane { border: 1px solid var(--border); border-radius: 10px; overflow: hidden; }
    #codeEditor { width: 100%; height: 360px; background: #0b0d10; color: #e8eef5; border: none; outline: none; font-family: 'Fira Code', 'Consolas', monospace; padding: 12px; font-size: 14px; line-height: 1.5; }
    .editor-bar { display: flex; gap: 8px; padding: 8px; border-top: 1px solid var(--border); }
    .build-log { border: 1px dashed var(--border); border-radius: 8px; padding: 8px; max-height: 160px; overflow: auto; font-size: 13px; }
    .log-item { margin: 4px 0; color: var(--muted); }
    .log-item strong { color: var(--text); }
    /* Polish */
    .btn:hover, .btn-icon:hover, .send:hover, .icon:hover, .burger:hover { filter: brightness(1.06); }
    .tab:hover, .tree-item:hover { filter: brightness(1.08); }
    .builder { box-shadow: 0 6px 28px rgba(0,0,0,0.25); }
    .bubble { box-shadow: 0 4px 18px rgba(0,0,0,0.18); }
    /* Toasts */
    #toastContainer { position: fixed; right: 16px; bottom: 16px; display: grid; gap: 10px; z-index: 2000; }
    .toast { background: var(--panel); border: 1px solid var(--border); color: var(--text); padding: 10px 12px; border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.35); display: grid; grid-auto-flow: column; align-items: center; gap: 10px; transition: opacity .25s ease, transform .25s ease; }
    .toast.ok { border-left: 3px solid var(--ok); }
    .toast.warn { border-left: 3px solid var(--warn); }
    .toast.err { border-left: 3px solid var(--err); }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="topbar-left">
      <button id="toggleSidebar" class="burger" aria-label="Menu">‚ò∞</button>
      <div class="brand">Buddy AI</div>
    </div>
    <div class="topbar-center">
      <div class="topbar-note small muted">No login. Refresh clears everything.</div>
    </div>
    <div class="topbar-right">
      
    </div>
  </div>
  <div id="toastContainer" aria-live="polite" aria-atomic="true"></div>
  <div id="thinkingPanel" class="dropdown hidden">
    <div class="sb-title" style="margin-bottom:6px">Thinking</div>
    <div id="thinkingList"></div>
  </div>
  <div id="backdrop" class="backdrop"></div>
  <aside id="sidebar" class="sidebar">
    <div class="sb-section" style="display:flex; justify-content: space-between; align-items:center;">
      <div class="sb-title" style="margin:0">Buddy AI</div>
      <button id="closeSidebar" class="icon" aria-label="Close">‚úï</button>
    </div>
    <div class="sb-section">
      <div class="sb-title">Chats</div>
      <button id="btnNewChat" class="btn" style="width:100%">+ New Chat</button>
      <div id="convList" style="margin-top:8px"></div>
    </div>
    <div class="sb-section sb-models" style="margin-top:auto;">
      <div class="sb-title-row">
        <div class="sb-title" style="margin:0">Models</div>
        <button id="modelsToggle" class="icon" aria-label="Toggle models">‚ñ∂</button>
      </div>
      <div id="modelList" class="model-list hidden"></div>
    </div>
  </aside>
  <div class="container" style="padding-top:64px">
    <div class="header"></div>

    <div class="input-bar" style="display:none">
      <textarea id="query_top" placeholder="Ask anything..."></textarea>
      <button id="sendBtnTop">Send</button>
    </div>

    <div class="chat" id="chat"></div>

    <div class="providers" id="providers" style="display:none"></div>

    <div class="bubble combined" id="combined" style="display:none"></div>

    <div id="builder" class="builder">
      <div class="builder-controls">
        <button id="btnStartBuild" class="btn">üõ†Ô∏è Build from prompt</button>
        <button id="btnStopBuild" class="btn">‚ñ† Stop</button>
        <button id="btnPreviewProject" class="btn">üëÅÔ∏è Preview</button>
        <button id="btnDownloadZip" class="btn">‚¨áÔ∏è Download ZIP</button>
        <button id="btnNewFile" class="btn">Ôºã New File</button>
        <button id="btnNewFolder" class="btn">üìÅ New Folder</button>
        <button id="btnDeleteSelected" class="btn">üóëÔ∏è Delete</button>
        <button id="btnClearProject" class="btn" style="margin-left:auto">‚ôªÔ∏è Clear Project</button>
      </div>
      <div class="builder-main">
        <div id="projectTree" class="project-tree"></div>
        <div class="right-pane">
          <div>
            <div class="editor-tabs">
              <button id="tabEditor" class="tab active">Editor</button>
              <button id="tabPreview" class="tab">Preview</button>
            </div>
          </div>
          <div id="paneEditor" class="editor-pane">
            <textarea id="codeEditor" spellcheck="false" placeholder="Select a file to edit..."></textarea>
            <div class="editor-bar">
              <span id="currentPath" class="small muted" style="flex:1 1 auto">No file selected</span>
              <button id="btnSaveFile" class="btn">üíæ Save</button>
            </div>
          </div>
          <div id="panePreview" class="preview-pane" style="display:none">
            <iframe id="projectPreview" class="preview-frame"></iframe>
          </div>
          <div>
            <div class="small muted" style="margin-bottom:4px">Build log</div>
            <div id="buildLog" class="build-log"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="spacer"></div>
  <div class="composer">
    <div class="composer-inner">
      <div class="attach">
        <label id="attachBtn" class="icon-btn" title="Attach (image or text)"><input id="attachInput" type="file" accept="image/*,.txt,.md,.json,application/json,text/plain"><span>üìé</span></label>
      </div>
      <textarea id="query" placeholder="Ask anything..."></textarea>
      <button class="send" id="sendBtn" aria-label="Send">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M3 11L21 3L13 21L11 13L3 11Z" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </button>
      <button class="send" id="buildBtn" title="Build from prompt">üõ†Ô∏è</button>
    </div>
    <div id="attachments" class="chips"></div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script>
    // Removed legacy provider map; we dynamically probe supported models

    const chatEl = document.getElementById('chat');
    const providersEl = document.getElementById('providers');
    const combinedEl = document.getElementById('combined');
    const queryEl = document.getElementById('query');
    const sendBtn = document.getElementById('sendBtn');
    const attachInput = document.getElementById('attachInput');
    const attachmentsEl = document.getElementById('attachments');
    let pendingImage = null; let pendingTextFile = null;
    const btnThinking = document.getElementById('btnThinking');
    const thinkingPanel = document.getElementById('thinkingPanel');
    const thinkingList = document.getElementById('thinkingList');
    const sidebar = document.getElementById('sidebar');
    const toggleSidebarBtn = document.getElementById('toggleSidebar');
    const closeSidebarBtn = document.getElementById('closeSidebar');
    const backdrop = document.getElementById('backdrop');
    const btnNewChat = document.getElementById('btnNewChat');
    const convList = document.getElementById('convList');
    const modelList = document.getElementById('modelList');
    const modelsToggle = document.getElementById('modelsToggle');

    let conversations = [];
    let activeConversationId = null;
    let history = [];
    let selectedModels = null;
    let hasUserModelSelection = false;

    // ------- Builder state -------
    const projectTreeEl = document.getElementById('projectTree');
    const codeEditorEl = document.getElementById('codeEditor');
    const currentPathEl = document.getElementById('currentPath');
    const paneEditorEl = document.getElementById('paneEditor');
    const panePreviewEl = document.getElementById('panePreview');
    const tabEditorEl = document.getElementById('tabEditor');
    const tabPreviewEl = document.getElementById('tabPreview');
    const projectPreviewEl = document.getElementById('projectPreview');
    const buildLogEl = document.getElementById('buildLog');
    const btnStartBuild = document.getElementById('btnStartBuild');
    const btnStopBuild = document.getElementById('btnStopBuild');
    const btnPreviewProject = document.getElementById('btnPreviewProject');
    const btnDownloadZip = document.getElementById('btnDownloadZip');
    const btnNewFile = document.getElementById('btnNewFile');
    const btnNewFolder = document.getElementById('btnNewFolder');
    const btnDeleteSelected = document.getElementById('btnDeleteSelected');
    const btnClearProject = document.getElementById('btnClearProject');
    const btnSaveFile = document.getElementById('btnSaveFile');
    const buildBtn = document.getElementById('buildBtn');

    let projectFiles = {}; // path -> content
    let selectedPath = null; // current file or folder path
    let isBuilding = false;
    let buildAbort = { aborted: false };

    // ------- Toasts -------
    function showToast(type, message) {
      const wrap = document.createElement('div');
      wrap.className = `toast ${type}`;
      wrap.innerHTML = `${type==='err'?'‚ùå':type==='warn'?'‚ö†Ô∏è':'‚úÖ'} <div>${escapeHtml(String(message))}</div>`;
      document.getElementById('toastContainer').appendChild(wrap);
      setTimeout(() => { wrap.style.opacity = '0'; wrap.style.transform='translateY(6px)'; }, 3500);
      setTimeout(() => wrap.remove(), 4200);
    }

    function persistProject() {
      try { localStorage.setItem('buddy_project_files', JSON.stringify(projectFiles)); } catch {}
    }
    function loadProject() {
      try {
        const raw = localStorage.getItem('buddy_project_files');
        if (raw) projectFiles = JSON.parse(raw) || {};
      } catch { projectFiles = {}; }
    }
    function addLog(msg) {
      const div = document.createElement('div');
      div.className = 'log-item';
      div.innerHTML = msg;
      buildLogEl.appendChild(div);
      buildLogEl.scrollTop = buildLogEl.scrollHeight;
    }
    function setBuilderBusy(b) {
      isBuilding = b;
      btnStartBuild.disabled = b;
      btnStopBuild.disabled = !b;
      buildBtn.disabled = b;
    }
    function ensureFolders(path) {
      const parts = path.split('/');
      let cur = '';
      for (let i = 0; i < parts.length - 1; i++) {
        cur = cur ? cur + '/' + parts[i] : parts[i];
        if (!(cur in projectFiles)) projectFiles[cur] = null; // folder marker: null content
      }
    }
    function isFolder(path) { return projectFiles[path] === null; }
    function listChildren(folder) {
      const prefix = folder ? folder + '/' : '';
      const children = new Set();
      Object.keys(projectFiles).forEach(p => {
        if (folder && p === folder) return; // skip self
        if (!folder && p.indexOf('/') === -1) { children.add(p.split('/')[0]); return; }
        if (p.startsWith(prefix)) {
          const rest = p.slice(prefix.length);
          const head = rest.split('/')[0];
          if (head) children.add(head);
        }
      });
      return Array.from(children).sort((a,b)=>a.localeCompare(b));
    }
    function renderProjectTree() {
      function renderNode(folderPath, container) {
        const items = listChildren(folderPath);
        items.forEach(name => {
          const full = folderPath ? folderPath + '/' + name : name;
          const hasSlash = Object.keys(projectFiles).some(p => p.startsWith(full + '/'));
          const isDir = hasSlash || isFolder(full);
          const row = document.createElement('div');
          row.className = 'tree-item' + (selectedPath === full ? ' active' : '');
          row.innerHTML = isDir ? `üìÅ <span class="tree-folder">${name}</span>` : `üìÑ <span>${name}</span>`;
          row.onclick = () => { selectPath(full); };
          container.appendChild(row);
          if (isDir) {
            const sub = document.createElement('div');
            sub.style.marginLeft = '16px';
            container.appendChild(sub);
            renderNode(full, sub);
          }
        });
      }
      projectTreeEl.innerHTML = '';
      const rootContainer = document.createElement('div');
      projectTreeEl.appendChild(rootContainer);
      renderNode('', rootContainer);
    }
    function selectPath(path) {
      selectedPath = path;
      renderProjectTree();
      currentPathEl.textContent = path || 'No file selected';
      if (path && projectFiles[path] !== null && projectFiles[path] !== undefined) {
        // file
        codeEditorEl.value = String(projectFiles[path] || '');
      } else {
        codeEditorEl.value = '';
      }
    }
    function saveCurrentFile() {
      if (!selectedPath || isFolder(selectedPath)) return;
      projectFiles[selectedPath] = codeEditorEl.value;
      persistProject();
      addLog(`<strong>Saved:</strong> ${escapeHtml(selectedPath)}`);
    }
    function newFile() {
      const base = prompt('New file path (e.g., src/app.js):');
      if (!base) return;
      ensureFolders(base);
      if (!(base in projectFiles)) projectFiles[base] = '';
      persistProject();
      renderProjectTree();
      selectPath(base);
    }
    function newFolder() {
      const base = prompt('New folder path (e.g., src/components):');
      if (!base) return;
      ensureFolders(base + '/x');
      projectFiles[base] = null;
      persistProject();
      renderProjectTree();
      selectPath(base);
    }
    function deleteSelected() {
      if (!selectedPath) return;
      if (!confirm(`Delete ${selectedPath}?`)) return;
      if (isFolder(selectedPath)) {
        // remove folder and all descendants
        Object.keys(projectFiles).forEach(p => { if (p === selectedPath || p.startsWith(selectedPath + '/')) delete projectFiles[p]; });
      } else {
        delete projectFiles[selectedPath];
      }
      persistProject();
      selectedPath = null;
      renderProjectTree();
      selectPath(null);
    }
    function clearProject() {
      if (!confirm('Clear entire project?')) return;
      projectFiles = {};
      persistProject();
      renderProjectTree();
      selectPath(null);
      addLog('<strong>Project cleared.</strong>');
    }
    function inlineAssets(html, baseFolder) {
      if (!html) return html;
      // Inline <link rel="stylesheet" href="...">
      html = html.replace(/<link[^>]+rel=["']stylesheet["'][^>]*href=["']([^"']+)["'][^>]*>/gi, (m, href) => {
        const path = (baseFolder ? baseFolder + '/' : '') + href.replace(/^\.\//,'');
        const content = projectFiles[href] ?? projectFiles[path];
        if (content != null) {
          return `<style>\n${content}\n</style>`;
        }
        return m;
      });
      // Inline <script src="...">
      html = html.replace(/<script[^>]*src=["']([^"']+)["'][^>]*><\/script>/gi, (m, src) => {
        const path = (baseFolder ? baseFolder + '/' : '') + src.replace(/^\.\//,'');
        const content = projectFiles[src] ?? projectFiles[path];
        if (content != null) {
          return `<script>\n${content}\n<\/script>`;
        }
        return m;
      });
      return html;
    }
    function previewProject() {
      let entry = projectFiles['index.html'] || projectFiles['public/index.html'] || '';
      if (!entry) {
        const html = '<!doctype html><html><body><p style="font-family:sans-serif">No index.html found.</p></body></html>';
        const doc = projectPreviewEl.contentWindow.document; doc.open(); doc.write(html); doc.close(); tabPreviewEl.click(); return;
      }
      entry = inlineAssets(entry, '');
      const doc = projectPreviewEl.contentWindow.document;
      doc.open();
      doc.write(entry);
      doc.close();
      tabPreviewEl.click();
    }
    async function downloadZip() {
      if (!window.JSZip) { showToast('err','Zip library not loaded.'); return; }
      const zip = new JSZip();
      for (const [p, content] of Object.entries(projectFiles)) {
        if (content === null) continue; // folder
        zip.file(p, content || '');
      }
      const blob = await zip.generateAsync({ type: 'blob' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'project.zip'; a.click();
      setTimeout(()=>URL.revokeObjectURL(url), 1000);
    }

    // Tabs
    tabEditorEl.onclick = () => { tabEditorEl.classList.add('active'); tabPreviewEl.classList.remove('active'); paneEditorEl.style.display='block'; panePreviewEl.style.display='none'; };
    tabPreviewEl.onclick = () => { tabPreviewEl.classList.add('active'); tabEditorEl.classList.remove('active'); paneEditorEl.style.display='none'; panePreviewEl.style.display='block'; };

    btnSaveFile.onclick = saveCurrentFile;
    btnNewFile.onclick = newFile;
    btnNewFolder.onclick = newFolder;
    btnDeleteSelected.onclick = deleteSelected;
    btnClearProject.onclick = clearProject;
    btnPreviewProject.onclick = previewProject;
    btnDownloadZip.onclick = downloadZip;

    // ------- Orchestrated builder pipeline -------
    function extractJson(text) {
      if (!text) return null;
      const fence = text.match(/```json\n([\s\S]*?)```/i);
      try { return JSON.parse(fence ? fence[1] : text); } catch { return null; }
    }
    function firstCodeFrom(text) {
      const m = text && text.match(/```(\w+)?\n([\s\S]*?)```/);
      return m ? { lang: (m[1]||'').toLowerCase(), code: m[2]||'' } : null;
    }
    async function orchestrateBuild(userPrompt) {
      setBuilderBusy(true); buildAbort = { aborted: false }; buildLogEl.innerHTML = '';
      addLog('<strong>Orchestrator:</strong> analyzing request...');
      const planMsgs = [
        { role: 'system', content: 'You are the Orchestrator for a multi-agent coding system (like v0.dev/bolt/lovable) focused ONLY on software development. Output a tight JSON: { goals: string[], tasks: string[], requiresSearch: boolean, techStack: string[], notes?: string }' },
        ...buildMessages(history, userPrompt)
      ];
      const planText = await askModelWithRetry(planMsgs, null);
      const plan = extractJson(planText) || { goals: [], tasks: [], requiresSearch: false, techStack: [], notes: '' };
      addLog(`<strong>Plan:</strong> ${escapeHtml(JSON.stringify(plan))}`);
      if (buildAbort.aborted) return;

      // Researcher
      let researchNotes = '';
      if (plan.requiresSearch) {
        addLog('<strong>Researcher:</strong> gathering context...');
        const researchMsgs = [
          { role: 'system', content: 'You are a Web Researcher. Without fabricating, compile a concise brief with references (titles and URLs) that will help implement the requested app. If unsure, state assumptions.' },
          { role: 'user', content: `Context to research: ${userPrompt}\n\nTasks: ${plan.tasks?.join('\n')}` }
        ];
        researchNotes = extractText(await askModelWithRetry(researchMsgs, null));
        addLog(`<strong>Research brief:</strong> ${escapeHtml(researchNotes.slice(0, 1200))}`);
      }
      if (buildAbort.aborted) return;

      // Architect
      addLog('<strong>Architect:</strong> proposing structure...');
      const archMsgs = [
        { role: 'system', content: 'You are a Software Architect. Output ONLY JSON describing the project structure. Schema: { files: Array<{ path: string, description?: string }>, entry?: string, notes?: string }. Prefer web projects with index.html and a src folder. No code content now.' },
        { role: 'user', content: `Prompt: ${userPrompt}\n\nGoals: ${JSON.stringify(plan.goals)}\nTech stack: ${JSON.stringify(plan.techStack)}\nResearch: ${researchNotes || 'N/A'}` }
      ];
      const archText = await askModelWithRetry(archMsgs, null);
      const arch = extractJson(archText) || { files: [{ path: 'index.html' }], entry: 'index.html' };
      const files = Array.isArray(arch.files) ? arch.files.map(f=>f.path) : ['index.html'];
      // create folders and empty files
      for (const p of files) { ensureFolders(p); if (!(p in projectFiles) || projectFiles[p] === null) projectFiles[p] = ''; }
      persistProject(); renderProjectTree();
      addLog(`<strong>Created</strong> ${files.length} files.`);
      if (buildAbort.aborted) return;

      // Coder
      addLog('<strong>Coder:</strong> generating code...');
      for (const p of files) {
        if (buildAbort.aborted) return;
        addLog(`Generating <strong>${escapeHtml(p)}</strong>...`);
        const ext = p.split('.').pop();
        const langHint = ext === 'js' ? 'javascript' : ext === 'ts' ? 'typescript' : ext === 'css' ? 'css' : ext === 'html' ? 'html' : '';
        const coderMsgs = [
          { role: 'system', content: 'You are a Senior Software Engineer. Generate COMPLETE code for the requested file only. Return ONLY one fenced code block with correct language. No explanations.' },
          { role: 'user', content: `Build an app as described: ${userPrompt}\nGoals: ${JSON.stringify(plan.goals)}\nTech: ${JSON.stringify(plan.techStack)}\nFile to implement: ${p}${arch.notes ? `\nArchitecture notes: ${arch.notes}` : ''}${researchNotes ? `\nRelevant research: ${researchNotes}` : ''}` }
        ];
        const codeResp = await askModelWithRetry(coderMsgs, null);
        const block = firstCodeFrom(codeResp);
        const content = block ? block.code : String(codeResp || '');
        // Progressive write for live feeling
        await writeFileProgressive(p, content);
        if (!selectedPath) selectPath(p); // select first file
      }
      addLog('<strong>Coder:</strong> done.');

      // Guide and Preview
      const guideMsgs = [
        { role: 'system', content: 'You are the Build Guide. Summarize what was created and how to run it locally in 5-7 bullets.' },
        { role: 'user', content: `Files: ${Object.keys(projectFiles).filter(p=>projectFiles[p]!==null).join(', ')}` }
      ];
      const guideText = await askModelWithRetry(guideMsgs, null);
      const aiIndex = history.length;
      history.push({ role: 'assistant', content: guideText, meta: { label: 'Guide' } });
      renderMessage('assistant', guideText, aiIndex);
      previewProject();
      setBuilderBusy(false);
    }
    btnStartBuild.onclick = () => { const q = queryEl.value.trim(); if (!q) { showToast('warn','Enter a prompt first.'); return; } orchestrateBuild(q); };
    buildBtn.onclick = () => { const q = queryEl.value.trim(); if (!q) { showToast('warn','Enter a prompt first.'); return; } orchestrateBuild(q); };
    btnStopBuild.onclick = () => { buildAbort.aborted = true; setBuilderBusy(false); addLog('<strong>Build aborted.</strong>'); showToast('warn','Build aborted.'); };

    // Load project on boot
    loadProject();
    renderProjectTree();

    async function writeFileProgressive(path, content) {
      ensureFolders(path);
      projectFiles[path] = '';
      persistProject();
      renderProjectTree();
      const lines = String(content || '').split(/\r?\n/);
      const chunkSize = 6;
      for (let i = 0; i < lines.length; i += chunkSize) {
        if (buildAbort.aborted) return;
        const chunk = lines.slice(i, i + chunkSize).join('\n') + (i + chunkSize < lines.length ? '\n' : '');
        projectFiles[path] += chunk;
        if (selectedPath === path) {
          codeEditorEl.value = projectFiles[path];
        }
        persistProject();
        await new Promise(r => setTimeout(r, 20));
      }
      addLog(`<strong>Wrote:</strong> ${escapeHtml(path)} (${lines.length} lines)`);
    }

    function escapeHtml(str) {
      return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
    }

    function buildMessages(historyArr, userQuery) {
      const msgs = [
        { role: 'system', content: 'You are an expert assistant. Provide accurate, concise, well-structured answers. Do not truncate your output. Return complete results.' }
      ];
      if (Array.isArray(historyArr)) {
        for (const m of historyArr) {
          if (!m || !m.role || !m.content) continue;
          if (m.role === 'user' || m.role === 'assistant' || m.role === 'system') {
            msgs.push({ role: m.role, content: String(m.content) });
          }
        }
      }
      if (userQuery && userQuery.trim()) {
        msgs.push({ role: 'user', content: userQuery });
      }
      return msgs;
    }

    function isErrorText(text) {
      return /^Error:/i.test(String(text || '').trim());
    }

    function isBlank(text) {
      return !String(text || '').trim();
    }

    function extractText(resp) {
      if (!resp) return '';
      if (typeof resp === 'string') return resp;
      if (resp.message?.content) return resp.message.content;
      if (Array.isArray(resp.choices)) {
        const ch = resp.choices[0];
        if (ch?.message?.content) return ch.message.content;
        if (ch?.text) return ch.text;
      }
      if (resp.output_text) return resp.output_text;
      if (resp.text) return resp.text;
      if (typeof resp.content === 'string') return resp.content;
      try { return JSON.stringify(resp); } catch { return String(resp); }
    }

    async function askModel(messages, modelId) {
      // Try object signature first; if that fails, fall back to (messages, options)
      try {
        const payload = modelId ? { model: modelId, messages } : { messages };
        const resp = await puter.ai.chat(payload);
        return extractText(resp);
      } catch (e1) {
        try {
          const resp = await puter.ai.chat(messages, modelId ? { model: modelId } : undefined);
          return extractText(resp);
        } catch (e2) {
          console.error(`Error with model ${modelId}:`, e2);
          return `Error: ${e2.message || "Failed to get response"}`;
        }
      }
    }

    async function askModelWithRetry(messages, modelId, maxTries = 3) {
      const tryModels = [];
      if (modelId) tryModels.push(modelId);
      tryModels.push(null); // default
      if (supportedModels && supportedModels.size) {
        if (supportedModels.has('gpt-4o')) tryModels.push('gpt-4o');
        tryModels.push(...Array.from(supportedModels).slice(0, 2));
      }
      let lastErr = 'Failed to get response';
      for (let t = 0; t < maxTries; t++) {
        for (const mid of tryModels) {
          const text = await askModel(messages, mid);
          if (text && !/^Error:/i.test(String(text))) return text;
          lastErr = typeof text === 'string' ? text.replace(/^Error:\s*/i,'') : 'Failed to get response';
        }
        await new Promise(r => setTimeout(r, 400 * (t + 1)));
      }
      showToast('err', `Model request failed: ${lastErr}`);
      return `Error: ${lastErr}`;
    }

    async function summarizeCombined(historyArr, query, answersByProvider, summarizer) {
      try {
        const ordered = Object.keys(answersByProvider);
        const bullets = ordered.map(p => `- ${p}: ${(answersByProvider[p] || '').slice(0, 8000)}`).join('\n');
        const prompt = `You are an expert editor that merges multiple AI answers into one concise, accurate, and well-structured response.\n\nUser query:\n${query}\n\nModel answers:\n${bullets}`;
        const msgs = [
          { role: 'system', content: 'You are a careful, reliable editor and synthesizer. Do not truncate. Include all critical details. Keep code complete.' },
          ...historyArr.filter(m => m.role === 'user' || m.role === 'assistant').slice(-6),
          { role: 'user', content: prompt },
        ];
        const response = await askModelWithRetry(msgs, summarizer);
        const respText = typeof response === 'string' ? response : extractText(response);
        if (respText && !/^Error:/i.test(respText.trim())) return respText;
        const fallbacks = Object.values(answersByProvider)
          .map(v => String(v || ''))
          .filter(v => v && !/^Error:/i.test(v.trim()));
        return fallbacks[0] || 'No combined answer could be generated';
      } catch (e) {
        console.error("Summarizer error:", e);
        return `Combined error: ${e.message || "Unknown error occurred during summarization"}`;
      }
    }

    const CANDIDATE_MODELS = [
      // Broad set; runtime probe will keep only working ones
      'gpt-4o', 'gpt-4o-mini', 'gpt-4.1', 'gpt-4.1-mini', 'gpt-4.1-nano',
      'o3-mini', 'o1-mini',
      'deepseek-chat', 'deepseek-reasoner',
      'x-ai/grok-4',
      'meta-llama/llama-3.3-70b-instruct',
      'claude-3-5-sonnet'
    ];

    let supportedModels = new Set();

    function loadSupportedModels() {
      try {
        const raw = localStorage.getItem('buddy_supported_models');
        if (!raw) return;
        const obj = JSON.parse(raw);
        if (!obj || !Array.isArray(obj.models)) return;
        supportedModels = new Set(obj.models);
      } catch {}
    }

    function saveSupportedModels() {
      try {
        localStorage.setItem('buddy_supported_models', JSON.stringify({ models: Array.from(supportedModels) }));
      } catch {}
    }

    async function probeModel(modelId) {
      try {
        const msgs = [ { role: 'user', content: 'ok?' } ];
        const text = await askModelWithRetry(msgs, modelId);
        return Boolean(text && !/^Error:/i.test(String(text)));
      } catch {
        return false;
      }
    }

    async function ensureSupportedModels() {
      if (supportedModels.size > 0) return;
      const probes = await Promise.all(
        CANDIDATE_MODELS.map(async (m) => ({ m, ok: await probeModel(m) }))
      );
      supportedModels = new Set(probes.filter(x => x.ok).map(x => x.m));
      if (supportedModels.size === 0) {
        // As a last resort, allow unspecified-model calls
        supportedModels = new Set([]);
      }
      saveSupportedModels();
    }

    async function runParallel(modelIds, historyArr, query, summarizer) {
      const messages = buildMessages(historyArr, query);
      const results = {};
      const tasks = [];
      
      thinkingList.innerHTML = '';
      const thinkItems = {};
      
      for (const model of modelIds) {
        const row = document.createElement('div');
        row.className = 'thinking-row';
        const dot = document.createElement('div');
        dot.className = 'dot pending';
        const name = document.createElement('div');
        name.textContent = model;
        const status = document.createElement('div');
        status.className = 'small muted';
        status.textContent = 'pending';
        row.appendChild(dot);
        row.appendChild(name);
        row.appendChild(status);
        thinkingList.appendChild(row);
        thinkItems[model] = { dot, status };
      }
      
      if (btnThinking) btnThinking.classList.remove('hidden');
      
      const ids = (modelIds && modelIds.length) ? modelIds : [];
      for (const model of ids) {
        tasks.push(
          askModelWithRetry(messages, model)
            .then((c) => {
              results[model] = c;
              const t = thinkItems[model];
              if (t) {
                t.dot.className = 'dot done';
                t.status.textContent = 'done';
              }
            })
            .catch((e) => {
              results[model] = `Error: ${e.message || "Unknown error"}`;
              const t = thinkItems[model];
              if (t) {
                t.dot.className = 'dot error';
                t.status.textContent = 'error';
              }
            })
        );
      }
      
      if (tasks.length) {
        await Promise.all(tasks);
      }
      
      try {
        const combined = await summarizeCombined(historyArr, query, results, summarizer);
        setTimeout(() => {
          if (thinkingPanel && btnThinking) {
            if (thinkingPanel.classList.contains('hidden')) {
              btnThinking.classList.add('hidden');
            }
          }
        }, 600);
        return { ...results, combined };
      } catch (e) {
        console.error("Final summarization error:", e);
        return {
          ...results,
          combined: `Failed to generate combined answer: ${e.message || "Unknown error"}`
        };
      }
    }

    function createToolbar(buttons) {
      const bar = document.createElement('div');
      bar.className = 'toolbar';
      for (const { title, icon, onClick } of buttons) {
        const b = document.createElement('button');
        b.className = 'btn btn-icon';
        b.title = title;
        b.innerHTML = icon;
        b.onclick = onClick;
        bar.appendChild(b);
      }
      return bar;
    }

    function extractFirstCodeBlock(text) {
      const m = text.match(/```(\w+)?\n([\s\S]*?)```/);
      if (!m) return null;
      return { lang: (m[1]||'').toLowerCase(), code: m[2]||'' };
    }

    function previewCode(code, lang) {
      const html = !lang || lang === 'html' ? code : `<!doctype html><html><head><style>body{margin:16px;}</style></head><body><pre>${escapeHtml(code)}</pre></body></html>`;
      const wrap = document.createElement('div');
      wrap.className = 'bubble assistant preview-container';
      wrap.innerHTML = '<div class="small muted">Preview</div>';

      const controls = document.createElement('div');
      controls.className = 'preview-controls';
      const btnDesktop = document.createElement('button'); btnDesktop.className = 'preview-device'; btnDesktop.textContent = 'Desktop';
      const btnTablet = document.createElement('button'); btnTablet.className = 'preview-device'; btnTablet.textContent = 'Tablet';
      const btnMobile = document.createElement('button'); btnMobile.className = 'preview-device'; btnMobile.textContent = 'Mobile';
      const btnFullscreen = document.createElement('button'); btnFullscreen.className = 'preview-device'; btnFullscreen.textContent = 'Fullscreen';
      const btnOpenWindow = document.createElement('button'); btnOpenWindow.className = 'preview-device'; btnOpenWindow.textContent = 'Open in new tab';
      controls.appendChild(btnDesktop); controls.appendChild(btnTablet); controls.appendChild(btnMobile); controls.appendChild(btnFullscreen); controls.appendChild(btnOpenWindow);
      wrap.appendChild(controls);

      const closeBtn = document.createElement('button');
      closeBtn.className = 'close-preview';
      closeBtn.innerHTML = '‚úï';
      closeBtn.onclick = () => wrap.remove();
      wrap.appendChild(closeBtn);
      
      const iframe = document.createElement('iframe');
      iframe.className = 'preview-frame';
      chatEl.appendChild(wrap);
      wrap.appendChild(iframe);
      const doc = iframe.contentWindow.document; 
      doc.open(); 
      doc.write(html); 
      doc.close();

      function setWidth(px) { iframe.style.width = px ? px + 'px' : '100%'; iframe.style.maxWidth = '100%'; }
      btnDesktop.onclick = () => setWidth(1100);
      btnTablet.onclick = () => setWidth(820);
      btnMobile.onclick = () => setWidth(420);
      btnFullscreen.onclick = () => wrap.classList.toggle('fullscreen');
      btnOpenWindow.onclick = () => {
        const w = window.open('', '_blank');
        if (!w) return;
        w.document.open();
        w.document.write(html);
        w.document.close();
      };

      wrap.scrollIntoView({ behavior: 'smooth', block: 'end' });
    }

    function renderMessage(role, content, index) {
      const div = document.createElement('div');
      const label = role === 'assistant' ? (history[index]?.meta?.label || 'Buddy') : role.toUpperCase();
      div.className = `bubble ${role}`;
      
      // Preserve markdown-like structure: bold, italic, underline, line breaks
      let formattedContent = content
        // code blocks
        .replace(/```(\w+)?\n([\s\S]*?)```/g, (match, lang, code) => `<pre><code class="language-${(lang||'')}">${escapeHtml(code)}</code></pre>`)
        // inline code
        .replace(/`([^`]+)`/g, (m, c) => `<code>${escapeHtml(c)}</code>`)
        // underline: __text__
        .replace(/__([^_]+)__/g, '<u>$1</u>')
        // bold: **text**
        .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
        // italics: *text*
        .replace(/(^|\s)\*([^*]+)\*(?=\s|$)/g, '$1<em>$2</em>')
        // newlines to paragraphs
        .replace(/\n\n+/g, '</p><p>')
        .replace(/\n/g, '<br/>');
      formattedContent = `<p>${formattedContent}</p>`;
      
      div.innerHTML = `<div class="small muted">${label}</div><div class="body">${formattedContent}</div>`;

      // Inline thinking toggle under the latest user bubble
      if (role === 'user' && index === history.length - 1) {
        const thinkToggle = document.createElement('button');
        thinkToggle.id = `think-toggle-${index}`;
        thinkToggle.className = 'thinking-toggle';
        thinkToggle.textContent = 'Thinking ‚ñ∏ 0s';
        const thinkPanel = document.createElement('div');
        thinkPanel.id = `think-panel-${index}`;
        thinkPanel.className = 'thinking-panel-inline hidden';
        const contentWrap = document.createElement('div');
        contentWrap.id = `think-content-${index}`;
        thinkPanel.appendChild(contentWrap);
        thinkToggle.onclick = () => toggleThinking(index);
        div.appendChild(thinkToggle);
        div.appendChild(thinkPanel);
      }
      
      const buttons = [];
      if (role === 'user') {
        buttons.push({ title: 'Copy', icon: 'üìã', onClick: () => navigator.clipboard.writeText(content) });
        buttons.push({ title: 'Edit', icon: '‚úèÔ∏è', onClick: () => editPrompt(index) });
        buttons.push({ title: 'Delete', icon: 'üóëÔ∏è', onClick: () => deletePrompt(index) });
      } else {
        buttons.push({ title: 'Copy Answer', icon: 'üìã', onClick: () => navigator.clipboard.writeText(content) });
        const code = extractFirstCodeBlock(content);
        if (code) buttons.push({ title: 'Preview', icon: 'üëÅÔ∏è', onClick: () => previewCode(code.code, code.lang) });
      }
      div.appendChild(createToolbar(buttons));
      chatEl.appendChild(div);
      div.scrollIntoView({ behavior: 'smooth', block: 'end' });
    }

    // Per-turn metadata for thinking view and labels
    const runMeta = new Map(); // key: userIndex -> { startMs, endMs, models: string[], results: Record<string,string>, combined: string }
    const runTimers = new Map(); // key: userIndex -> interval id

    function secondsBetween(startMs, endMs) {
      if (!startMs) return 0;
      const end = endMs || Date.now();
      return Math.max(0, Math.round((end - startMs) / 1000));
    }

    function updateThinkingToggleText(index, isOpen) {
      const meta = runMeta.get(index);
      const secs = secondsBetween(meta?.startMs, meta?.endMs);
      const caret = isOpen ? '‚ñæ' : '‚ñ∏';
      return `Thinking ${caret} ${secs}s`;
    }

    function renderInlineThinking(index) {
      const panel = document.getElementById(`think-content-${index}`);
      if (!panel) return;
      panel.innerHTML = '';
      const meta = runMeta.get(index);
      if (!meta) {
        // Fallback to live statuses
        const rows = [...thinkingList.children];
        for (const r of rows) {
          const copy = r.cloneNode(true);
          copy.classList.add('thinking-row');
          panel.appendChild(copy);
        }
        return;
      }
      // Models used header
      const header = document.createElement('div');
      header.className = 'small muted';
      header.innerHTML = `Models used: <em>${(meta.models||[]).join(', ') || 'default'}</em>`;
      panel.appendChild(header);
      // Each model thought
      for (const m of meta.models || []) {
        const wrap = document.createElement('div');
        wrap.className = 'thinking-row';
        const title = document.createElement('div');
        title.innerHTML = `<strong>${m}</strong>`;
        const body = document.createElement('div');
        const text = String((meta.results && meta.results[m]) || '').slice(0, 1200);
        body.innerHTML = `<em>${escapeHtml(text || 'thinking‚Ä¶')}</em>`;
        wrap.appendChild(title);
        wrap.appendChild(body);
        panel.appendChild(wrap);
      }
      // How Buddy combined
      const combine = document.createElement('div');
      combine.className = 'thinking-row';
      combine.innerHTML = `<div><strong>Buddy combine</strong></div><div><em>Merged overlapping points, resolved conflicts, and structured the final answer.</em></div>`;
      panel.appendChild(combine);
    }

    function startThinkingTimer(index) {
      stopThinkingTimer(index);
      const id = setInterval(() => {
        const toggle = document.getElementById(`think-toggle-${index}`);
        if (!toggle) return;
        const panel = document.getElementById(`think-panel-${index}`);
        const isOpen = panel && !panel.classList.contains('hidden');
        toggle.textContent = updateThinkingToggleText(index, isOpen);
      }, 1000);
      runTimers.set(index, id);
    }

    function stopThinkingTimer(index) {
      const id = runTimers.get(index);
      if (id) {
        clearInterval(id);
        runTimers.delete(index);
      }
    }

    function toggleThinking(index) {
      const panel = document.getElementById(`think-panel-${index}`);
      const toggle = document.getElementById(`think-toggle-${index}`);
      if (!panel || !toggle) return;
      const opening = panel.classList.contains('hidden');
      panel.classList.toggle('hidden');
      toggle.textContent = updateThinkingToggleText(index, opening);
      if (opening) {
        renderInlineThinking(index);
      }
    }

    function renderProviders(outputs) {
      // Suppress provider outputs globally to focus on combined reply.
      providersEl.innerHTML = '';
      providersEl.style.display = 'none';
    }

    function renderCombined(_text) {
      // Suppressed: combined answer is shown only as the Buddy reply bubble
      combinedEl.style.display = 'none';
      combinedEl.innerHTML = '';
    }

    function setSidebarOpen(open) {
      if (open) { 
        sidebar.classList.add('open'); 
        backdrop.classList.add('show'); 
      } else { 
        sidebar.classList.remove('open'); 
        backdrop.classList.remove('show'); 
      }
    }
    
    toggleSidebarBtn.addEventListener('click', () => setSidebarOpen(!sidebar.classList.contains('open')));
    closeSidebarBtn.addEventListener('click', () => setSidebarOpen(false));
    backdrop.addEventListener('click', () => setSidebarOpen(false));

    queryEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        send();
      }
    });

    sendBtn.addEventListener('click', send);

    attachInput.addEventListener('change', async (e) => {
      const file = e.target.files?.[0]; 
      if (!file) return;
      
      if (file.type.startsWith('image/')) {
        try {
          const dataUrl = await fileToDataURL(file);
          pendingImage = dataUrl;
          const chip = document.createElement('div'); 
          chip.className='chip'; 
          chip.textContent = `Image: ${file.name}`; 
          attachmentsEl.appendChild(chip);
        } catch (e) {
          console.error("Error processing image:", e);
        }
      } else if (file.type.startsWith('text') || /\.(md|json|txt)$/i.test(file.name)) {
        try {
          pendingTextFile = await file.text();
          const chip = document.createElement('div'); 
          chip.className='chip'; 
          chip.textContent = `File: ${file.name}`; 
          attachmentsEl.appendChild(chip);
        } catch (e) {
          console.error("Error reading text file:", e);
        }
      } else {
        showToast('warn','Only images or text/md/json files are supported.');
      }
      e.target.value = '';
    });

    function fileToDataURL(file) { 
      return new Promise((resolve, reject) => { 
        const r = new FileReader(); 
        r.onload = () => resolve(r.result); 
        r.onerror = reject; 
        r.readAsDataURL(file); 
      }); 
    }

    async function ocrImage(dataUrl) {
      try {
        return await puter.ai.img2txt(dataUrl);
      } catch (e1) {
        try {
          return await puter.ai.img2txt({ image: dataUrl });
        } catch (e2) {
          console.error('Image OCR error:', e2);
          return null;
        }
      }
    }

    let inFlightAbort = null;

    function setComposeBusy(busy) {
      if (busy) {
        sendBtn.classList.add('stop');
        sendBtn.title = 'Stop';
        sendBtn.innerHTML = '‚ñ†';
        document.getElementById('attachBtn').classList.add('disabled');
      } else {
        sendBtn.classList.remove('stop');
        sendBtn.title = 'Send';
        sendBtn.innerHTML = `
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M3 11L21 3L13 21L11 13L3 11Z" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>`;
        document.getElementById('attachBtn').classList.remove('disabled');
      }
    }

    function abortAll() {
      if (inFlightAbort) inFlightAbort.abort();
    }

    sendBtn.onclick = () => {
      if (sendBtn.classList.contains('stop')) {
        abortAll();
      } else {
        send();
      }
    };

    async function send() {
      const q = queryEl.value.trim();
      if (!q) return;
      
      setComposeBusy(true);
      queryEl.value = '';

      let enriched = q;
      if (pendingImage) {
        const text = await ocrImage(pendingImage);
        if (text) enriched += `\n\n[Image OCR]:\n${text}`;
      }
      if (pendingTextFile) {
        enriched += `\n\n[Attached text]:\n${pendingTextFile.slice(0, 20000)}`;
      }

      const userIndex = history.length;
      const msg = { role: 'user', content: enriched };
      if (pendingImage) msg.images = [pendingImage];
      if (pendingTextFile) msg.files = [{ name: 'attachment.txt', type: 'text/plain', content: pendingTextFile.slice(0, 20000) }];
      
      history.push(msg);
      // track run meta for this user turn and start timer
      runMeta.set(userIndex, { startMs: Date.now(), models: null, results: null, combined: null });
      renderMessage('user', enriched, userIndex);
      startThinkingTimer(userIndex);
      attachmentsEl.innerHTML = '';
      pendingImage = null;
      pendingTextFile = null;

      try {
        inFlightAbort = new AbortController();
        await ensureSupportedModels();
        const baseList = supportedModels.size ? Array.from(supportedModels) : [];
        let modelsToUse = Array.from(selectedModels || new Set(baseList)).filter(m => !supportedModels.size || supportedModels.has(m));
        if (hasUserModelSelection) {
          const chosen = Array.from(selectedModels || []);
          modelsToUse = chosen.filter(m => !supportedModels.size || supportedModels.has(m));
        }
        const summarizerModel = (supportedModels.has('gpt-4o') ? 'gpt-4o' : (modelsToUse[0] || null));
        const startMs = Date.now();
        // store which models are used for thinking view
        const meta = runMeta.get(userIndex) || {};
        meta.models = modelsToUse.slice();
        const result = await runParallel(modelsToUse, history, enriched, summarizerModel);
        renderProviders(result);
        renderCombined(result.combined);
        let assistantContent = result.combined || '';
        const nonErrorProvider = Object.entries(result)
          .filter(([k, v]) => k !== 'combined' && typeof v === 'string')
          .map(([_, v]) => v)
          .find(v => !isErrorText(v));
        if (isBlank(assistantContent) || isErrorText(assistantContent)) {
          if (nonErrorProvider && !isBlank(nonErrorProvider)) {
            assistantContent = nonErrorProvider;
          } else {
            const fallbackMessages = buildMessages(history, '');
            const fallback = await askModelWithRetry(fallbackMessages, null);
            const fallbackText = extractText(fallback);
            assistantContent = isBlank(fallbackText) || isErrorText(fallbackText) ? '[No combined answer could be generated]' : fallbackText;
          }
        }
        const aiIndex = history.length;
        const label = (modelsToUse && modelsToUse.length > 1) ? 'Buddy - Combined' : 'Buddy';
        meta.results = Object.fromEntries(Object.entries(result).filter(([k]) => k !== 'combined'));
        meta.combined = assistantContent;
        meta.endMs = Date.now();
        runMeta.set(userIndex, meta);
        history.push({ role: 'assistant', content: assistantContent, meta: { label } });
        renderMessage('assistant', assistantContent, aiIndex);
        stopThinkingTimer(userIndex);
      } catch (e) {
        console.error("Send error:", e);
        const errorMsg = `Error: ${e.message || "Failed to get response"}`;
        const aiIndex = history.length;
        history.push({ role: 'assistant', content: errorMsg });
        renderMessage('assistant', errorMsg, aiIndex);
        try { showToast('err','Failed to get response. Please try again.'); } catch {}
      } finally {
        inFlightAbort = null;
        setComposeBusy(false);
      }
    }

    let activeEditIndex = null;
    function editPrompt(index) {
      if (activeEditIndex !== null) return;
      const original = history[index]; 
      if (!original || original.role !== 'user') return;
      
      activeEditIndex = index;
      const bubbles = [...chatEl.children];
      const bubble = bubbles[index];
      if (!bubble) return;
      
      const body = bubble.querySelector('.body');
      const originalText = original.content;
      body.innerHTML = '';
      
      const ta = document.createElement('textarea');
      ta.style.width = '100%'; 
      ta.style.minHeight = '120px'; 
      ta.style.maxHeight = 'none'; 
      ta.value = originalText;
      
      const bar = document.createElement('div'); 
      bar.className = 'toolbar';
      
      const saveBtn = document.createElement('button'); 
      saveBtn.className = 'btn'; 
      saveBtn.textContent = 'Save';
      
      const cancelBtn = document.createElement('button'); 
      cancelBtn.className = 'btn'; 
      cancelBtn.textContent = 'Cancel';
      
      bar.appendChild(saveBtn); 
      bar.appendChild(cancelBtn);
      body.appendChild(ta); 
      body.appendChild(bar);
      
      saveBtn.onclick = () => saveEdit(index, ta.value);
      cancelBtn.onclick = () => cancelEdit(index, originalText);
    }

    function cancelEdit(index, originalText) {
      activeEditIndex = null;
      const bubbles = [...chatEl.children];
      const bubble = bubbles[index]; 
      if (!bubble) return;
      
      const body = bubble.querySelector('.body');
      body.textContent = originalText;
    }

    function saveEdit(index, newText) {
      activeEditIndex = null;
      history[index].content = newText;
      while (history.length > index + 1) history.pop();
      
      chatEl.innerHTML = '';
      for (let i=0;i<=index;i++) {
        renderMessage(history[i].role, history[i].content, i);
      }
      
      (async () => {
        setComposeBusy(true);
      try {
          await ensureSupportedModels();
          const baseList = supportedModels.size ? Array.from(supportedModels) : [];
          let modelsToUse = Array.from(selectedModels || new Set(baseList)).filter(m => !supportedModels.size || supportedModels.has(m));
          if (hasUserModelSelection) {
            const chosen = Array.from(selectedModels || []);
            modelsToUse = chosen.filter(m => !supportedModels.size || supportedModels.has(m));
          }
          const summarizerModel = (supportedModels.has('gpt-4o') ? 'gpt-4o' : (modelsToUse[0] || null));
          const startMs = Date.now();
          const result = await runParallel(modelsToUse, history, newText, summarizerModel);
          renderProviders(result);
          renderCombined(result.combined);
          let assistantContent = result.combined || '';
          const nonErrorProvider = Object.entries(result)
            .filter(([k, v]) => k !== 'combined' && typeof v === 'string')
            .map(([_, v]) => v)
            .find(v => !isErrorText(v));
          if (isBlank(assistantContent) || isErrorText(assistantContent)) {
            if (nonErrorProvider && !isBlank(nonErrorProvider)) {
              assistantContent = nonErrorProvider;
            } else {
              const fallbackMessages = buildMessages(history, '');
              const fallback = await askModelWithRetry(fallbackMessages, null);
              const fallbackText = extractText(fallback);
              assistantContent = isBlank(fallbackText) || isErrorText(fallbackText) ? '[No combined answer could be generated]' : fallbackText;
            }
          }
          const aiIndex = history.length;
          const label = (modelsToUse && modelsToUse.length > 1) ? 'Buddy - Combined' : 'Buddy';
          const meta = runMeta.get(index) || {};
          meta.endMs = Date.now();
          runMeta.set(index, meta);
          history.push({ role: 'assistant', content: assistantContent, meta: { label } });
          renderMessage('assistant', assistantContent, aiIndex);
          stopThinkingTimer(index);
        } catch (e) {
          console.error("Error after edit:", e);
        } finally { 
          setComposeBusy(false);
        }
      })();
    }

    function deletePrompt(index) {
      if (!history[index] || history[index].role !== 'user') return;
      history.splice(index);
      chatEl.innerHTML = '';
      for (let i=0;i<history.length;i++) {
        renderMessage(history[i].role, history[i].content, i);
      }
    }

    function saveState() {
      const state = { 
        conversations, 
        activeConversationId, 
        selectedModels: Array.from(selectedModels || []) 
      };
      localStorage.setItem('buddy_state', JSON.stringify(state));
    }

    function loadState() {
      try {
        const raw = localStorage.getItem('buddy_state');
        if (!raw) throw new Error('no saved state');
        const st = JSON.parse(raw);
        conversations = Array.isArray(st.conversations) ? st.conversations : [];
        activeConversationId = st.activeConversationId || null;
        const base = supportedModels.size ? Array.from(supportedModels) : CANDIDATE_MODELS;
        const restored = Array.isArray(st.selectedModels) && st.selectedModels.length ? st.selectedModels : base;
        selectedModels = new Set(restored.filter(m => !supportedModels.size || supportedModels.has(m)));
      } catch {
        conversations = [];
        activeConversationId = null;
        const base = supportedModels.size ? Array.from(supportedModels) : CANDIDATE_MODELS;
        selectedModels = new Set(base);
      }
    }

    function ensureDefaultConversation() {
      if (!conversations.length) {
        const conv = { 
          id: String(Date.now()), 
          name: 'New Chat', 
          history: [] 
        };
        conversations.push(conv);
        activeConversationId = conv.id;
      }
    }

    function setActiveConversation(id) {
      activeConversationId = id;
      const conv = conversations.find(c => c.id === id);
      history = conv.history;
      chatEl.innerHTML = '';
      for (let i=0;i<history.length;i++) {
        renderMessage(history[i].role, history[i].content, i);
      }
      saveState();
      renderConversationList();
    }

    function newChat() {
      const conv = { 
        id: String(Date.now()), 
        name: 'New Chat', 
        history: [] 
      };
      conversations.unshift(conv);
      saveState();
      setActiveConversation(conv.id);
    }

    function renameConversation(id, newName) {
      const c = conversations.find(x => x.id === id); 
      if (!c) return;
      c.name = newName || 'Untitled';
      saveState();
      renderConversationList();
    }

    function deleteConversation(id) {
      const idx = conversations.findIndex(x => x.id === id);
      if (idx === -1) return;
      
      conversations.splice(idx,1);
      if (!conversations.length) {
        ensureDefaultConversation();
      }
      
      if (activeConversationId === id) {
        setActiveConversation(conversations[0].id);
      } else {
        saveState();
        renderConversationList();
      }
    }

    async function exportConversationPdf(id) {
      const c = conversations.find(x => x.id === id); 
      if (!c) return;
      
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF({ unit: 'pt', format: 'a4' });
      const pageWidth = doc.internal.pageSize.getWidth();
      let y = 36;
      const lineHeight = 16;
      
      doc.setFont('helvetica',''); 
      doc.setFontSize(12);
      doc.text(`Conversation: ${c.name}`, 36, y); 
      y += 24;
      
      for (const m of c.history) {
        doc.setFont(undefined,'bold'); 
        doc.text(m.role.toUpperCase()+':', 36, y); 
        y += lineHeight; 
        doc.setFont(undefined,'normal');
        
        const text = (m.content || '').replace(/\r/g,'');
        const lines = doc.splitTextToSize(text, pageWidth-72);
        
        for (const ln of lines) { 
          if (y > 780) { 
            doc.addPage(); 
            y = 36; 
          } 
          doc.text(ln, 36, y); 
          y += lineHeight; 
        }
        
        if (Array.isArray(m.images)) {
          for (const img of m.images) { 
            if (y > 700) { 
              doc.addPage(); 
              y = 36; 
            } 
            try { 
              doc.addImage(img, 'PNG', 36, y, pageWidth-72, (pageWidth-72)*0.56); 
              y += 12 + (pageWidth-72)*0.56; 
            } catch (e) {
              console.error("Error adding image:", e);
            } 
          }
        }
        
        if (Array.isArray(m.files)) {
          for (const f of m.files) {
            const label = f.type && f.type.startsWith('text') ? `File (${f.name}):` : `Attachment: ${f.name}`;
            if (y > 780) { 
              doc.addPage(); 
              y = 36; 
            }
            doc.setFont(undefined,'bold'); 
            doc.text(label, 36, y); 
            y += lineHeight; 
            doc.setFont(undefined,'normal');
            
            if (f.content && typeof f.content === 'string') {
              const flines = doc.splitTextToSize(f.content.slice(0,5000), pageWidth-72);
              for (const ln of flines) { 
                if (y > 780) { 
                  doc.addPage(); 
                  y = 36; 
                } 
                doc.text(ln, 36, y); 
                y += lineHeight; 
              }
            }
          }
        }
        y += 8;
      }
      doc.save(`${c.name.replace(/[^a-z0-9\-_]+/gi,'_')}.pdf`);
    }

    function renderConversationList() {
      convList.innerHTML = '';
      for (const c of conversations) {
        const row = document.createElement('div'); 
        row.className='conv-item';
        
        const input = document.createElement('input'); 
        input.className='conv-name'; 
        input.value = c.name; 
        input.title='Click to edit name';
        input.onchange = () => renameConversation(c.id, input.value);
        input.onclick = (e) => { 
          if (activeConversationId !== c.id) setActiveConversation(c.id); 
        };
        
        const del = document.createElement('button'); 
        del.className='icon'; 
        del.textContent='üóëÔ∏è'; 
        del.title='Delete'; 
        del.onclick = () => deleteConversation(c.id);
        
        const exp = document.createElement('button'); 
        exp.className='icon'; 
        exp.textContent='‚¨áÔ∏è'; 
        exp.title='Export PDF'; 
        exp.onclick = () => exportConversationPdf(c.id);
        
        row.appendChild(input); 
        row.appendChild(exp); 
        row.appendChild(del);
        
        if (activeConversationId === c.id) {
          row.style.borderColor = 'var(--accent)';
        }
        
        convList.appendChild(row);
      }
    }

    function renderModelList() {
      modelList.innerHTML = '';
      const list = supportedModels.size ? Array.from(supportedModels) : CANDIDATE_MODELS;
      for (const mid of list) {
        const row = document.createElement('label'); 
        row.className='model-row';
        
        const cb = document.createElement('input'); 
        cb.type='checkbox'; 
        cb.checked = (selectedModels||new Set(list)).has(mid);
        cb.onchange = () => { 
          if (!selectedModels) selectedModels = new Set(list); 
          if (cb.checked) selectedModels.add(mid); 
          else selectedModels.delete(mid); 
          hasUserModelSelection = true;
          saveState(); 
        };
        
        const span = document.createElement('span'); 
        span.textContent = mid;
        
        row.appendChild(cb); 
        row.appendChild(span);
        modelList.appendChild(row);
      }
    }

    btnNewChat.addEventListener('click', newChat);
    
    if (btnThinking && thinkingPanel) {
      btnThinking.addEventListener('click', () => {
        const open = thinkingPanel.classList.contains('hidden');
        if (open) { 
          thinkingPanel.classList.remove('hidden'); 
        } else { 
          thinkingPanel.classList.add('hidden'); 
          if (!thinkingList.querySelector('.dot.pending')) { 
            btnThinking.classList.add('hidden'); 
          } 
        }
      });
    }
    
    if (modelsToggle && modelList) {
      modelsToggle.addEventListener('click', (e) => {
        e.stopPropagation();
        const closed = modelList.classList.contains('hidden');
        if (closed) { 
          modelList.classList.remove('hidden'); 
          modelsToggle.textContent = '‚ñº'; 
        } else { 
          modelList.classList.add('hidden'); 
          modelsToggle.textContent = '‚ñ∂'; 
        }
      });
      document.addEventListener('click', (e) => {
        const within = modelList.contains(e.target) || modelsToggle.contains(e.target);
        if (!within) {
          modelList.classList.add('hidden');
          modelsToggle.textContent = '‚ñ∂';
        }
      });
    }

    // Initialize the app
    (async () => {
      loadSupportedModels();
      await ensureSupportedModels();
      loadState();
      ensureDefaultConversation();
      history = (conversations.find(c => c.id === activeConversationId) || conversations[0]).history;
      activeConversationId = (conversations.find(c => c.id === activeConversationId) || conversations[0]).id;
      renderConversationList();
      renderModelList();
      setActiveConversation(activeConversationId);
    })();
  </script>
</body>
</html>
